<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>fntom.LevelEquivalence API documentation</title>
<meta name="description" content="Definition of class `LevelEquivalence` which implements a finite negative
tomonoid partition." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fntom.LevelEquivalence</code></h1>
</header>
<section id="section-intro">
<p>Definition of class <code><a title="fntom.LevelEquivalence.LevelEquivalence" href="#fntom.LevelEquivalence.LevelEquivalence">LevelEquivalence</a></code> which implements a finite negative
tomonoid partition.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: UTF-8 -*-

# This file is a part of fntom which is a Python3 package that implements a
# finite, negative, totally ordered monoid together with methods to compute its
# one-element Rees co-extensions.
#
# Copyright (C) 2021 Milan Petr√≠k &lt;milan.petrik@protonmail.com&gt;
#
# Web page of the program: &lt;https://gitlab.com/petrikm/fntom&gt;
#
# fntom is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# fntom is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# fntom. If not, see &lt;https://www.gnu.org/licenses/&gt;.

&#34;&#34;&#34;
    Definition of class `LevelEquivalence` which implements a finite negative
    tomonoid partition.
&#34;&#34;&#34;

__all__ = [&#34;LevelEquivalence&#34;]

import copy
import fntom

class LevelEquivalence:
    &#34;&#34;&#34;
    Implements level set equivalence of a finite negative tomonoid (i.e. f. n.
    tomonoid partition).

    Attributes:
        size (int): size of the f. n. tomonoid
        eqClasses (list of sets of 2-tuples of int): level set equivalence classes
        zero (int, const): the bottom element of the f. n. tomonoid
        unit (int, const): the unit element of the f. n. tomonoid which is also
            the top element
        atom (int, const): the highest element smaller than the top element
        coatom (int, const): the lowest element higher than the bottom element
    &#34;&#34;&#34;

    def __init__(self,
                 size = None,
                 original = None,
                 base62Table = None,
                 intTable = None,
                 xyzTable = None):
        &#34;&#34;&#34;
        At maximum one of the arguments `size`, `original`, `xyzTable`,
        `intTable` can be specified.
        If none of them is specified, the level set equivalence is initialized
        to represent the trivial monoid.

        Args:
            size (int): must be greater or equal to 1; if specified, the level
                set equivalence will represent a f. n. tomonoid of the given size,
                however, all the pairs will form singletons in the equivalence with
                the exception of:

                  * the pairs of the form (1,x) and (x,1) which will be
                    pairwise related
                  * the pairs of the form (0,x) or (x,0) which will be
                    alltogether related

            original (LevelEquivalence): if specified, this level set
                equivalence will be a (deep) copy of the `original`

            base62Table (list of lists of chr): if specified, the level set
                equivalence will be created according to the given Cayley table;
                the values in the table are supposed to be from the set:
                `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`
                where `0` represents the neutral element (unit)

            intTable (list of lists of int): if specified, the level set
                equivalence will be created according to the given Cayley table;
                the values in the table are supposed to be non-negative
                integers starting from `0` (which represents the unit element)

            xyzTable (list of lists of chr): if specified, the level set
                equivalence will be created according to the given Cayley table;
                the values in the table are supposed to be from the set:
                `&#34;0&#34;`, ..., `&#34;x&#34;`, `&#34;y&#34;`, `&#34;z&#34;`, `&#34;1&#34;`
                and the table is supposed to have its second index reversed,
                i.e., the table is left-right flipped (accoding to vertical
                axis)
                This style of depicting the Cayley table corresponds with
                the style used in the referenced papers
                [PeVe14,PeVe16,PeVe17,PeVe19], while the previous two
                styles reflect the inner representation of the tomonoid.

        Example:
            The level equivalence of the Lukasiewicz f. n. tomonoid of the size
            10 could be initialized by:

                base62Table = [
                    [&#34;0&#34;, &#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34;, &#34;5&#34;, &#34;6&#34;, &#34;7&#34;, &#34;8&#34;, &#34;9&#34;, &#34;A&#34;],
                    [&#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34;, &#34;5&#34;, &#34;6&#34;, &#34;7&#34;, &#34;8&#34;, &#34;9&#34;, &#34;A&#34;, &#34;A&#34;],
                    [&#34;2&#34;, &#34;3&#34;, &#34;4&#34;, &#34;5&#34;, &#34;6&#34;, &#34;7&#34;, &#34;8&#34;, &#34;9&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;],
                    [&#34;3&#34;, &#34;4&#34;, &#34;5&#34;, &#34;6&#34;, &#34;7&#34;, &#34;8&#34;, &#34;9&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;],
                    [&#34;4&#34;, &#34;5&#34;, &#34;6&#34;, &#34;7&#34;, &#34;8&#34;, &#34;9&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;],
                    [&#34;5&#34;, &#34;6&#34;, &#34;7&#34;, &#34;8&#34;, &#34;9&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;],
                    [&#34;6&#34;, &#34;7&#34;, &#34;8&#34;, &#34;9&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;],
                    [&#34;7&#34;, &#34;8&#34;, &#34;9&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;],
                    [&#34;8&#34;, &#34;9&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;],
                    [&#34;9&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;],
                    [&#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;]]
                lvlEq = fntom.LevelEquivalence(base62Table = base62Table)

            or it could be initialized by:

                intTable = [
                    [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10],
                    [ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 10],
                    [ 2,  3,  4,  5,  6,  7,  8,  9, 10, 10, 10],
                    [ 3,  4,  5,  6,  7,  8,  9, 10, 10, 10, 10],
                    [ 4,  5,  6,  7,  8,  9, 10, 10, 10, 10, 10],
                    [ 5,  6,  7,  8,  9, 10, 10, 10, 10, 10, 10],
                    [ 6,  7,  8,  9, 10, 10, 10, 10, 10, 10, 10],
                    [ 7,  8,  9, 10, 10, 10, 10, 10, 10, 10, 10],
                    [ 8,  9, 10, 10, 10, 10, 10, 10, 10, 10, 10],
                    [ 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10],
                    [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]]
                lvlEq = fntom.LevelEquivalence(intTable = intTable)

            or it could be initialized by:

                xyzTable = [
                    [&#34;0&#34;, &#34;r&#34;, &#34;s&#34;, &#34;t&#34;, &#34;u&#34;, &#34;v&#34;, &#34;w&#34;, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;, &#34;1&#34;],
                    [&#34;0&#34;, &#34;0&#34;, &#34;r&#34;, &#34;s&#34;, &#34;t&#34;, &#34;u&#34;, &#34;v&#34;, &#34;w&#34;, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;],
                    [&#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;r&#34;, &#34;s&#34;, &#34;t&#34;, &#34;u&#34;, &#34;v&#34;, &#34;w&#34;, &#34;x&#34;, &#34;y&#34;],
                    [&#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;r&#34;, &#34;s&#34;, &#34;t&#34;, &#34;u&#34;, &#34;v&#34;, &#34;w&#34;, &#34;x&#34;],
                    [&#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;r&#34;, &#34;s&#34;, &#34;t&#34;, &#34;u&#34;, &#34;v&#34;, &#34;w&#34;],
                    [&#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;r&#34;, &#34;s&#34;, &#34;t&#34;, &#34;u&#34;, &#34;v&#34;],
                    [&#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;r&#34;, &#34;s&#34;, &#34;t&#34;, &#34;u&#34;],
                    [&#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;r&#34;, &#34;s&#34;, &#34;t&#34;],
                    [&#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;r&#34;, &#34;s&#34;],
                    [&#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;r&#34;]]
                    [&#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;]]
                lvlEq = fntom.LevelEquivalence(xyzTable = xyzTable)

        &#34;&#34;&#34;
        if size != None:
            self.size = size
            self.setDesignatedValues()
            self.eqClasses = self.size * [None]
            for i in range(self.size):
                self.eqClasses[i] = set([])
            # pairs with unit coordinate
            self.eqClasses[self.unit].update(set([(self.unit,self.unit)]))
            for i in range(self.coatom, self.size, 1):
                self.eqClasses[i].update(set([(i,self.unit), (self.unit,i)]))
            # pairs with zero coordinate
            self.eqClasses[self.zero].update(set([(self.zero,self.zero)]))
            for i in range(self.coatom, self.zero, 1):
                self.eqClasses[self.zero].update(set([(i,self.zero), (self.zero,i)]))
            # add all the other pairs - each pair to its own equivalence class
            for i in range(self.coatom, self.zero, 1):
                for j in range(self.coatom, self.zero, 1):
                    self.eqClasses.append(set([(i,j)]))
        elif original != None:
            self.size = original.size
            self.eqClasses = copy.deepcopy(original.eqClasses)
            self.zero = original.zero
            self.unit = original.unit
            self.atom = original.atom
            self.coatom = original.coatom
        elif base62Table != None:
            self.size = len(base62Table)
            self.setDesignatedValues()
            self.eqClasses = self.size * [None]
            for i in range(self.size):
                self.eqClasses[i] = set([])
            for i in range(self.size):
                for j in range(self.size):
                    value = fntom.convertBase62ToDecimal(base62Table[i][j])
                    self.eqClasses[value].add((i, j))
        elif intTable != None:
            self.size = len(intTable)
            self.setDesignatedValues()
            self.eqClasses = self.size * [None]
            for i in range(self.size):
                self.eqClasses[i] = set([])
            for i in range(self.size):
                for j in range(self.size):
                    value = intTable[i][j]
                    self.eqClasses[value].add((i, j))
        elif xyzTable != None:
            self.size = len(xyzTable)
            self.setDesignatedValues()
            self.eqClasses = self.size * [None]
            for i in range(self.size):
                self.eqClasses[i] = set([])
            for i in range(self.size):
                for j in range(self.size):
                    char = xyzTable[i][j]
                    #value = self.getElementCode(char)
                    value = fntom.convert0xyz1ToDecimal(char, self.size)
                    self.eqClasses[value].add((i, self.size - 1 - j))
        else:
            self.size = 1
            self.setDesignatedValues()
            self.eqClasses = [ set([ (self.unit,self.unit) ]) ]

    def setDesignatedValues(self):
        &#34;&#34;&#34;
        According to the value of the attribute `size`, sets the values of
        `zero`, `unit`, `atom`, and `coatom`.
        &#34;&#34;&#34;
        if self.size == 1:
            self.zero = self.unit = self.atom = self.coatom = 0
        else:
            self.zero = self.size - 1
            self.unit = 0
            self.atom = self.size - 2
            self.coatom = 1

    def getCopy(self):
        &#34;&#34;&#34;
            Returns:
                LevelEquivalence: a deep copy of this instance
        &#34;&#34;&#34;
        return LevelEquivalence(original = self)

    def findIdempotents(self):
        &#34;&#34;&#34;
        Finds and returns all the non-trivial idempotents.

        An element x is an idempotent if x*x=x (where * is the monoidal
            operation).

        Hence if an equivalence class indexed by x that contains the pair (x,x)
        is found then the value x is an idempotent.

        Note that the top element 1 and the bottom element 0 is an idempotent
        of every f. n. tomonoid; these values are called trivial idempotents.
        These values are not included in the returned list of idempotents.

        Returns:
            list of int: list of the non-trivial idempotents
        &#34;&#34;&#34;
        idempotents = []
        for x in range(self.coatom, self.zero, 1):
            if self.getValue((x,x)) == x:
                idempotents.append(x)
        return idempotents

    def performZeroDoublingExtension(self):
        &#34;&#34;&#34;
        Performs the zero-doubling extension on this tomonoid.

          * Removes all the pairs from the level set equivalence that are
            equivalent with (0, 1) and (1, 0).
          * Enlarges the size of the tomonoid by one adding a new bottom
            element.
          * Recomputes the values of `zero`, `unit`, `atom`, and `coatom`.
        &#34;&#34;&#34;
        formerSize = self.size

        self.size += 1
        self.setDesignatedValues()

        numEqClasses = len(self.eqClasses)
        if numEqClasses &gt; formerSize:
            # move the last class behind former zero to the end of the list
            self.eqClasses.append(self.eqClasses[self.zero])
            # add (1,0), (0,1), and (0,0) to the zero class
            self.eqClasses[self.zero] = set([(self.unit, self.zero), (self.zero, self.unit), (self.zero, self.zero)])
        else:
            # add (1,0), (0,1), and (0,0) to the zero class
            self.eqClasses.append(set([(self.unit, self.zero), (self.zero, self.unit), (self.zero, self.zero)]))

        # add pairs of type (x,0) and (0,x) to the zero class
        for i in range(self.coatom, self.zero, 1):
            self.eqClasses[self.zero].add((self.zero,i))
            self.eqClasses[self.zero].add((i,self.zero))

        # atom class (former zero class) is used to determine all the single
        # pair undefined equivalence classes
        if self.size &gt; 2:
            for pair in self.eqClasses[self.atom]:
                if self.isNotOnBorder(pair):
                    self.eqClasses.append(set([pair]))

        # setting the atom class to (1,at)~(at,1)
        self.eqClasses[self.atom] = set([(self.unit, self.atom), (self.atom, self.unit)])

    def findEqClass(self, pair):
        &#34;&#34;&#34;
        Finds the class to which the given pair belongs.

        Args:
            pair (2-tuple of int): the searched pair

        Returns:
            2-tuple: `(class, index)` where `class` is the reference to the
                class containing the `pair` while `index` is the index in the
                list `eqClasses`

        Raises:
            Exception: if the pair has not been found
        &#34;&#34;&#34;
        numEqClasses = len(self.eqClasses)
        for i in range(numEqClasses):
            if pair in self.eqClasses[i]:
                return (self.eqClasses[i], i)
        raise Exception(&#34;ERROR: Pair&#34;, pair, &#34;has not been found&#34;)

    def isElement(self, value):
        &#34;&#34;&#34;
        Args:
            value (int): index of level equivalence class in `eqClasses`

        Returns:
            bool: `True` if `value` is an element of the monoid
        &#34;&#34;&#34;
        return self.unit &lt;= value &lt;= self.zero

    def isAtomOrHigher(self, value):
        &#34;&#34;&#34;
        Args:
            value (int): index of level equivalence class in `eqClasses`

        Returns:
            bool: `True` if `value` is an element of the monoid that is not
                equal to `zero`
        &#34;&#34;&#34;
        return self.unit &lt;= value &lt; self.zero

    def isHigherThanAtom(self, value):
        &#34;&#34;&#34;
        Args:
            value (int): index of level equivalence class in `eqClasses`

        Returns:
            bool: `True` if `value` is an element of the monoid that is neither
                equal to `zero` nor to `atom`
        &#34;&#34;&#34;
        return self.isElement(value) and value &lt; self.atom

    def isZeroOrAtomOrNotElement(self, value):
        &#34;&#34;&#34;
        Args:
            value (int): index of level equivalence class in `eqClasses`

        Returns:
            bool: `True` if `value` is equal to `zero` or to `atom` or if it is
                not an element of the monoid
        &#34;&#34;&#34;
        return value == self.zero or value == self.atom or not self.isElement(value)

    def isAtomOrNotElement(self, value):
        &#34;&#34;&#34;
        Args:
            value (int): index of level equivalence class in `eqClasses`

        Returns:
            bool: `True` if `value` is equal to `atom` or if it is not an
                element of the monoid
        &#34;&#34;&#34;
        return value == self.atom or not self.isElement(value)

    def isNotOnBorder(self, pair):
        &#34;&#34;&#34;
        Args:
            value (2-tuple of int): pair of monoid elements

        Returns:
            bool: `True` if the pair does lie neither on the axis given by the
                zero element nor on the axis given by the unit element
        &#34;&#34;&#34;
        return self.zero &gt; pair[0] &gt; self.unit and self.zero &gt; pair[1] &gt; self.unit

    def setValue(self, pair, value):
        &#34;&#34;&#34;
        Defines the value to which the given pair is supposed to be evaluated
        by the monoidal operation.

        It, actually, merges (relates) the class that contains `pair` with the
        class that contains the pairs `(1,value)` and `(value,1)`.

        Args:
            pair (2-tuple of int): the pair
            value (int): to which value is the pair supposed to be evaluated
                (the index of the class)
        &#34;&#34;&#34;
        (cla, ind) = self.findEqClass(pair)
        if ind != value:
            if self.isElement(ind):
                raise fntom.Error.NotTOMPartition([ind, value], self)
            else:
                self.eqClasses[value].update(cla)
                self.eqClasses.remove(cla)

    def getValue(self, pair):
        &#34;&#34;&#34;
        Returns the value of the given pair according to the monoidal
        operation.

        A value outside of the range of the monoidal values may be returned if
        the pair belongs to a class that does not contain pairs of the type
        `(1,x)`, `(x,1)`.

        Args:
            pair (2-tuple of int): the pair

        Returns:
            int: the value of the pair according to the monoidal operation
                (i.e., the index of the level equivalence class to which the
                pair belongs)
        &#34;&#34;&#34;
        (cla, ind) = self.findEqClass(pair)
        return ind

    def relateClasses(self, ind1, ind2):
        &#34;&#34;&#34;
        Merges two level equivalence classes into one.

        Args:
            ind1 (int): index of the first class in `eqClasses`
            ind2 (int): index of the second class in `eqClasses`

        Raises:
            fntom.Error.NotTOMPartition: if both the classes contain pairs of
                the types (1,x) and (x,1)
        &#34;&#34;&#34;
        if ind1 != ind2:
            if self.isElement(ind2):
                if self.isElement(ind1):
                    raise fntom.Error.NotTOMPartition([ind1, ind2], self)
                else:
                    self.eqClasses[ind2].update(self.eqClasses[ind1])
                    self.eqClasses.remove(self.eqClasses[ind1])
            else:
                self.eqClasses[ind1].update(self.eqClasses[ind2])
                self.eqClasses.remove(self.eqClasses[ind2])

    #TODO !!! neni resen pripad, kdy pair1 nebo pair2 neni v zadne tride
    def relatePairs(self, pair1, pair2):
        &#34;&#34;&#34;
        Merges the level equivalence classes that contain the given pairs.

        Args:
            pair1 (2-tuple of int): first pair
            pair2 (2-tuple of int): second pair

        Raises:
            fntom.Error.NotTOMPartition: if both the classes contain pairs of
                the types (1,x) and (x,1)
        &#34;&#34;&#34;
        if pair1 != pair2:
            (cla1, ind1) = self.findEqClass(pair1)
            (cla2, ind2) = self.findEqClass(pair2)
            self.relateClasses(ind1, ind2)

    def setPairToZero(self, pair):
        &#34;&#34;&#34;
        Adds the given pair to the zero equivalence class.

        Merges the class that contains the pair with the class that contains
        (1,0) and (0,1).
        Furthermore, the monotonicity of the tomonoid is taken into account,
        i.e., all the pairs that are closer to (0,0) are added to the zero
        equivalence class, as well.

        Args:
            pair (2-tuple of int): the pair that is to be evaluated to zero by
                the monoidal operation
        &#34;&#34;&#34;
        if self.isNotOnBorder(pair):
            for i in range(pair[0], self.zero, 1):
                for j in range(pair[1], self.zero, 1):
                    (cla, ind) = self.findEqClass(pair)
                    self.mergeEqClassWithZero(ind)

    def mergeEqClassWithZero(self, ind):
        &#34;&#34;&#34;
        Merges the given level equivalence class with the zero equivalence
            class.

        Merges the given class with the class that contains (1,0) and (0,1).
        Furthermore, the monotonicity of the tomonoid is taken into account,
        i.e., all the pairs that are closer to (0,0) (compared to the pairs of
        the given class) are added to the zero equivalence class, as well.

        Args:
            ind (int): index of the class in `eqClasses`

        Raises:
            fntom.Error.NotTOMPartition: if both the classes contain pairs of
                the types (1,x) and (x,1)
        &#34;&#34;&#34;
        if not self.isElement(ind):
            cla = self.eqClasses[ind]
            self.eqClasses[self.zero].update(cla)
            self.eqClasses.remove(cla)
            for pair in cla:
                self.setPairToZero((pair[0]+1,pair[1]))
                self.setPairToZero((pair[0],pair[1]+1))
        elif self.isAtomOrHigher(ind):
            raise fntom.Error.NotTOMPartition([self.zero, ind], self)

    def setPairToAtom(self, pair):
        &#34;&#34;&#34;
        Adds the given pair to the atom equivalence class.

        Merges the class that contains the pair with the class that contains
        (1,atom) and (atom,1).
        Furthermore, the monotonicity of the tomonoid is taken into account,
        i.e., all the pairs that are closer to (1,1) are added to the atom
        equivalence class, as well.

        Args:
            pair (2-tuple of int): the pair that is to be evaluated to atom by
                the monoidal operation
        &#34;&#34;&#34;
        if self.isNotOnBorder(pair):
            for i in range(pair[0], self.unit, -1):
                for j in range(pair[1], self.unit, -1):
                    (cla, ind) = self.findEqClass(pair)
                    self.mergeEqClassWithAtom(ind)

    def mergeEqClassWithAtom(self, ind):
        &#34;&#34;&#34;
        Merges the given level equivalence class with the atom equivalence
            class.

        Merges the given class with the class that contains (1,atom) and (atom,1).
        Furthermore, the monotonicity of the tomonoid is taken into account,
        i.e., all the pairs that are closer to (1,1) (compared to the pairs of
        the given class) are added to the atom equivalence class, as well.

        Args:
            ind (int): index of the class in `eqClasses`

        Raises:
            fntom.Error.NotTOMPartition: if both the classes contain pairs of
                the types (1,x) and (x,1)
        &#34;&#34;&#34;
        if not self.isElement(ind):
            cla = self.eqClasses[ind]
            self.eqClasses[self.atom].update(cla)
            self.eqClasses.remove(cla)
            for pair in cla:
                self.setPairToAtom((pair[0]-1,pair[1]))
                self.setPairToAtom((pair[0],pair[1]-1))
        elif ind == self.zero:
            raise fntom.Error.NotTOMPartition([self.zero, self.atom], self)

    def setRestToZero(self):
        &#34;&#34;&#34;
        Sets all the undetermined pairs to zero.

        Undetermined pairs are those that are contained in the equivalence
        classes with their indices out of the range of the tomonoid values.
        &#34;&#34;&#34;
        numClasses = len(self.eqClasses)
        for ind in range(numClasses - 1, self.size - 1, -1):
            self.relateClasses(ind, self.zero)

    def relateColumn(self, x, yFrom, yTo):
        &#34;&#34;&#34;
        Makes the pairs in a bounded column of the Cayley table level
        equivalent.

        This involves the pairs in the range from `(x, yFrom)` to `(x, yTo)`.

        The value of `yFrom` does not need to be lower than `yTo` (or vice
        versa).

        Args:
            x (int): an element of the monoid
            yFrom (int): an element of the monoid
            yTo (int): an element of the monoid
        &#34;&#34;&#34;
        if yFrom == yTo:
            return
        elif yFrom &lt; yTo:
            rang = range(yFrom, yTo+1, 1)
        elif yFrom &gt; yTo:
            rang = range(yTo, yFrom+1, 1)
        first = None
        for y in rang:
            if first == None:
                first = (x,y)
            else:
                self.relatePairs(first, (x,y))

    def relateRow(self, xFrom, xTo, y):
        &#34;&#34;&#34;
        Makes the pairs in a bounded row of the Cayley table level equivalent.

        This involves the pairs in the range from `(xFrom, y)` to `(xTo, y)`.

        The value of `xFrom` does not need to be lower than `xTo` (or vice
        versa).

        Args:
            xFrom (int): an element of the monoid
            xTo (int): an element of the monoid
            y (int): an element of the monoid
        &#34;&#34;&#34;
        if xFrom == xTo:
            return
        elif xFrom &lt; xTo:
            ran = range(xFrom, xTo+1, 1)
        elif xFrom &gt; xTo:
            ran = range(xTo, xFrom+1, 1)
        first = None
        for x in ran:
            if first == None:
                first = (x,y)
            else:
                self.relatePairs(first, (x,y))

    def getTable(self):
        &#34;&#34;&#34;
        Constructs the Cayley table of the tomonoid.

        The table is constructed according to the level set equivalence.

        Returns:
            list of list of int: the Cayley table
        &#34;&#34;&#34;
        table = []
        for i in range(self.size):
            table.append(self.size * [-1])
        for eqClassIndex in range(len(self.eqClasses)):
            for pair in self.eqClasses[eqClassIndex]:
                (i, j) = pair
                table[i][j] = eqClassIndex
        return table

    def performAssociativityTest(self):
        &#34;&#34;&#34;
        Tests whether the operaration defined by the level set equivalence is
        associative.

        Returns:
            3-tuple of int: `None` if it is associative, `(x, y, z)` if it is
                not associative; the triplet `(x, y, z)` contains the values on
                which the associativity test has failed
        &#34;&#34;&#34;
        table = self.getTable()
        for x in range(self.size):
            for y in range(self.size):
                for z in range(self.size):
                    xy = table[x][y]
                    yz = table[y][z]
                    if table[xy][z] != table[x][yz]:
                        return (x, y, z)
        return None

    def performMonotonicityTest(self):
        &#34;&#34;&#34;
        Tests whether the operaration defined by the level set equivalence is
        monotone.

        Returns:
            2-tuple of int: `None` if it is monotone, `(x, y)` if it is not
                monotone; the pair `(x, y)` contains the values on which the
                monotonicity test has failed
        &#34;&#34;&#34;
        table = self.getTable()
        for x in range(0, self.size-1, 1):
            for y in range(0, self.size-1, 1):
                if table[x+1][y] &lt; table[x][y] or table[x][y+1] &lt; table[x][y]:
                    return (x, y)
        return None

    def performArchimedeanicityTest(self):
        &#34;&#34;&#34;
        Tests whether the operaration defined by the level set equivalence is
        Archimedean.

        Returns:
            int: `None` if it is Archimedean, a single integer value if it is
                not Archimedean; the value is one of the non-trivial idempotents of
                the monoid
        &#34;&#34;&#34;
        table = self.getTable()
        for x in range(1, self.size-1, 1):
            if table[x][x] &lt;= x:
                return x
        return None

    def performCommutativityTest(self):
        &#34;&#34;&#34;
        Tests whether the operaration defined by the level set equivalence is
        commutative.

        Returns:
            2-tuple of int: `None` if it is commutative, `(x, y)` if it is not
                commutative; the pair `(x, y)` contains the values on which the
                commutativity test has failed
        &#34;&#34;&#34;
        table = self.getTable()
        for x in range(self.size):
            for y in range(self.size):
                if table[x][y] != table[y][x]:
                    return (x, y)
        return None

    def exportClassesToText(self):
        &#34;&#34;&#34;
        Returns:
            str: description of the level equivalence classes; suitable to be
                printed to the terminal output
        &#34;&#34;&#34;
        text = &#34;&#34;
        numClasses = len(self.eqClasses)
        for i in range(numClasses):
            textPart = str(i) + &#34;: &#34;
            initialLength = len(textPart)
            lineLength = initialLength
            text += textPart
            first = True
            for (a, b) in self.eqClasses[i]:
                if first:
                    first = False
                else:
                    text += &#34; &#34;
                    lineLength += 1
                textPart = &#34;(&#34; + str(a) + &#34;,&#34; + str(b) + &#34;)&#34;
                if lineLength + len(textPart) &gt; 78:
                    text += &#34;\n&#34;
                    text += initialLength * &#34; &#34;
                    text += textPart
                    lineLength = initialLength + len(textPart)
                else:
                    text += textPart
                    lineLength += len(textPart)

            text += &#34;\n&#34;
        return text

    def exportTableToText(self, separator = &#34;, &#34;, endLine = &#34;\n&#34;, tableSymbols = &#34;base62&#34;):
        &#34;&#34;&#34;
        Args:
            separator (str, optional): string that separates the values in the
                table

            endLine (str, optional): string that separates the rows of the
                table

            tableSymbols (str, optional): one of the following three values:

                * &#34;base62&#34; (default) ... the element of the tomonoid will be
                    diplayed as symbls from the number system 62, that is, the
                    characters from
                    `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`
                    where `0` represents the neutral element (unit)
                * &#34;int&#34; ... the element of the tomonoid will be diplayed as
                    non-negative integers starting from `0` which will represent
                    the neutral element (unit)
                * &#34;0xyz1&#34; ...  the element of the tomonoid will be diplayed as
                    the characters from the set:
                    `&#34;0&#34;`, ..., `&#34;x&#34;`, `&#34;y&#34;`, `&#34;z&#34;`, `&#34;1&#34;`
                    In this case, the table will be left-right flipped
                    (according to the vertical axis).
                    This style of depicting the Cayley table corresponds with
                    the style used in the referenced papers
                    [PeVe14,PeVe16,PeVe17,PeVe19], while the previous two
                    styles reflect the inner representation of the tomonoid.

        Returns:
            str: Cayley table of the monoid;
                suitable be written to a text file or to the terminal output
        &#34;&#34;&#34;
        table = self.getTable()
        text = &#34;&#34;
        if tableSymbols == &#34;int&#34;:
            width = len(str(len(self.eqClasses) - 1))
        else:
            width = 1
        for i in range(self.size):
            if i &gt; 0:
                text += endLine
            first = True
            for j in range(self.size):
                if first:
                    first = False
                else:
                    text += separator
                if tableSymbols == &#34;0xyz1&#34;:
                    value = table[i][self.size - 1 - j]
                else:
                    value = table[i][j]
                if tableSymbols == &#34;base62&#34;:
                    if value == None:
                        text += &#34;?&#34;
                    else:
                        text += fntom.convertDecimalToBase62(value)
                elif tableSymbols == &#34;int&#34;:
                    text += f&#39;{value:&gt;{width}}&#39;
                elif tableSymbols == &#34;0xyz1&#34;:
                    text += fntom.convertDecimalTo0xyz1(value, self.size)
        return text

    def show(self):
        &#34;&#34;&#34;
        Prints the values of the attributes of this instance to the terminal
            output.

        Mostly for debugging purposes.
        &#34;&#34;&#34;
        print(self.exportTableToText())
        print(self.exportClassesToText())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fntom.LevelEquivalence.LevelEquivalence"><code class="flex name class">
<span>class <span class="ident">LevelEquivalence</span></span>
<span>(</span><span>size=None, original=None, base62Table=None, intTable=None, xyzTable=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Implements level set equivalence of a finite negative tomonoid (i.e. f. n.
tomonoid partition).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>size of the f. n. tomonoid</dd>
<dt><strong><code>eqClasses</code></strong> :&ensp;<code>list</code> of <code>sets</code> of <code>2-tuples</code> of <code>int</code></dt>
<dd>level set equivalence classes</dd>
<dt><strong><code>zero</code></strong> :&ensp;<code>int, const</code></dt>
<dd>the bottom element of the f. n. tomonoid</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>int, const</code></dt>
<dd>the unit element of the f. n. tomonoid which is also
the top element</dd>
<dt><strong><code>atom</code></strong> :&ensp;<code>int, const</code></dt>
<dd>the highest element smaller than the top element</dd>
<dt><strong><code>coatom</code></strong> :&ensp;<code>int, const</code></dt>
<dd>the lowest element higher than the bottom element</dd>
</dl>
<p>At maximum one of the arguments <code>size</code>, <code>original</code>, <code>xyzTable</code>,
<code>intTable</code> can be specified.
If none of them is specified, the level set equivalence is initialized
to represent the trivial monoid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>must be greater or equal to 1; if specified, the level
set equivalence will represent a f. n. tomonoid of the given size,
however, all the pairs will form singletons in the equivalence with
the exception of:</p>
<ul>
<li>the pairs of the form (1,x) and (x,1) which will be
pairwise related</li>
<li>the pairs of the form (0,x) or (x,0) which will be
alltogether related</li>
</ul>
</dd>
<dt><strong><code>original</code></strong> :&ensp;<code><a title="fntom.LevelEquivalence.LevelEquivalence" href="#fntom.LevelEquivalence.LevelEquivalence">LevelEquivalence</a></code></dt>
<dd>if specified, this level set
equivalence will be a (deep) copy of the <code>original</code></dd>
<dt><strong><code>base62Table</code></strong> :&ensp;<code>list</code> of <code>lists</code> of <code>chr</code></dt>
<dd>if specified, the level set
equivalence will be created according to the given Cayley table;
the values in the table are supposed to be from the set:
<code>0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</code>
where <code>0</code> represents the neutral element (unit)</dd>
<dt><strong><code>intTable</code></strong> :&ensp;<code>list</code> of <code>lists</code> of <code>int</code></dt>
<dd>if specified, the level set
equivalence will be created according to the given Cayley table;
the values in the table are supposed to be non-negative
integers starting from <code>0</code> (which represents the unit element)</dd>
<dt><strong><code>xyzTable</code></strong> :&ensp;<code>list</code> of <code>lists</code> of <code>chr</code></dt>
<dd>if specified, the level set
equivalence will be created according to the given Cayley table;
the values in the table are supposed to be from the set:
<code>"0"</code>, &hellip;, <code>"x"</code>, <code>"y"</code>, <code>"z"</code>, <code>"1"</code>
and the table is supposed to have its second index reversed,
i.e., the table is left-right flipped (accoding to vertical
axis)
This style of depicting the Cayley table corresponds with
the style used in the referenced papers
[PeVe14,PeVe16,PeVe17,PeVe19], while the previous two
styles reflect the inner representation of the tomonoid.</dd>
</dl>
<h2 id="example">Example</h2>
<p>The level equivalence of the Lukasiewicz f. n. tomonoid of the size
10 could be initialized by:</p>
<pre><code>base62Table = [
    ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A"],
    ["1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "A"],
    ["2", "3", "4", "5", "6", "7", "8", "9", "A", "A", "A"],
    ["3", "4", "5", "6", "7", "8", "9", "A", "A", "A", "A"],
    ["4", "5", "6", "7", "8", "9", "A", "A", "A", "A", "A"],
    ["5", "6", "7", "8", "9", "A", "A", "A", "A", "A", "A"],
    ["6", "7", "8", "9", "A", "A", "A", "A", "A", "A", "A"],
    ["7", "8", "9", "A", "A", "A", "A", "A", "A", "A", "A"],
    ["8", "9", "A", "A", "A", "A", "A", "A", "A", "A", "A"],
    ["9", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A"],
    ["A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A"]]
lvlEq = fntom.LevelEquivalence(base62Table = base62Table)
</code></pre>
<p>or it could be initialized by:</p>
<pre><code>intTable = [
    [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10],
    [ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 10],
    [ 2,  3,  4,  5,  6,  7,  8,  9, 10, 10, 10],
    [ 3,  4,  5,  6,  7,  8,  9, 10, 10, 10, 10],
    [ 4,  5,  6,  7,  8,  9, 10, 10, 10, 10, 10],
    [ 5,  6,  7,  8,  9, 10, 10, 10, 10, 10, 10],
    [ 6,  7,  8,  9, 10, 10, 10, 10, 10, 10, 10],
    [ 7,  8,  9, 10, 10, 10, 10, 10, 10, 10, 10],
    [ 8,  9, 10, 10, 10, 10, 10, 10, 10, 10, 10],
    [ 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10],
    [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]]
lvlEq = fntom.LevelEquivalence(intTable = intTable)
</code></pre>
<p>or it could be initialized by:</p>
<pre><code>xyzTable = [
    ["0", "r", "s", "t", "u", "v", "w", "x", "y", "z", "1"],
    ["0", "0", "r", "s", "t", "u", "v", "w", "x", "y", "z"],
    ["0", "0", "0", "r", "s", "t", "u", "v", "w", "x", "y"],
    ["0", "0", "0", "0", "r", "s", "t", "u", "v", "w", "x"],
    ["0", "0", "0", "0", "0", "r", "s", "t", "u", "v", "w"],
    ["0", "0", "0", "0", "0", "0", "r", "s", "t", "u", "v"],
    ["0", "0", "0", "0", "0", "0", "0", "r", "s", "t", "u"],
    ["0", "0", "0", "0", "0", "0", "0", "0", "r", "s", "t"],
    ["0", "0", "0", "0", "0", "0", "0", "0", "0", "r", "s"],
    ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "r"]]
    ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0"]]
lvlEq = fntom.LevelEquivalence(xyzTable = xyzTable)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LevelEquivalence:
    &#34;&#34;&#34;
    Implements level set equivalence of a finite negative tomonoid (i.e. f. n.
    tomonoid partition).

    Attributes:
        size (int): size of the f. n. tomonoid
        eqClasses (list of sets of 2-tuples of int): level set equivalence classes
        zero (int, const): the bottom element of the f. n. tomonoid
        unit (int, const): the unit element of the f. n. tomonoid which is also
            the top element
        atom (int, const): the highest element smaller than the top element
        coatom (int, const): the lowest element higher than the bottom element
    &#34;&#34;&#34;

    def __init__(self,
                 size = None,
                 original = None,
                 base62Table = None,
                 intTable = None,
                 xyzTable = None):
        &#34;&#34;&#34;
        At maximum one of the arguments `size`, `original`, `xyzTable`,
        `intTable` can be specified.
        If none of them is specified, the level set equivalence is initialized
        to represent the trivial monoid.

        Args:
            size (int): must be greater or equal to 1; if specified, the level
                set equivalence will represent a f. n. tomonoid of the given size,
                however, all the pairs will form singletons in the equivalence with
                the exception of:

                  * the pairs of the form (1,x) and (x,1) which will be
                    pairwise related
                  * the pairs of the form (0,x) or (x,0) which will be
                    alltogether related

            original (LevelEquivalence): if specified, this level set
                equivalence will be a (deep) copy of the `original`

            base62Table (list of lists of chr): if specified, the level set
                equivalence will be created according to the given Cayley table;
                the values in the table are supposed to be from the set:
                `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`
                where `0` represents the neutral element (unit)

            intTable (list of lists of int): if specified, the level set
                equivalence will be created according to the given Cayley table;
                the values in the table are supposed to be non-negative
                integers starting from `0` (which represents the unit element)

            xyzTable (list of lists of chr): if specified, the level set
                equivalence will be created according to the given Cayley table;
                the values in the table are supposed to be from the set:
                `&#34;0&#34;`, ..., `&#34;x&#34;`, `&#34;y&#34;`, `&#34;z&#34;`, `&#34;1&#34;`
                and the table is supposed to have its second index reversed,
                i.e., the table is left-right flipped (accoding to vertical
                axis)
                This style of depicting the Cayley table corresponds with
                the style used in the referenced papers
                [PeVe14,PeVe16,PeVe17,PeVe19], while the previous two
                styles reflect the inner representation of the tomonoid.

        Example:
            The level equivalence of the Lukasiewicz f. n. tomonoid of the size
            10 could be initialized by:

                base62Table = [
                    [&#34;0&#34;, &#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34;, &#34;5&#34;, &#34;6&#34;, &#34;7&#34;, &#34;8&#34;, &#34;9&#34;, &#34;A&#34;],
                    [&#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34;, &#34;5&#34;, &#34;6&#34;, &#34;7&#34;, &#34;8&#34;, &#34;9&#34;, &#34;A&#34;, &#34;A&#34;],
                    [&#34;2&#34;, &#34;3&#34;, &#34;4&#34;, &#34;5&#34;, &#34;6&#34;, &#34;7&#34;, &#34;8&#34;, &#34;9&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;],
                    [&#34;3&#34;, &#34;4&#34;, &#34;5&#34;, &#34;6&#34;, &#34;7&#34;, &#34;8&#34;, &#34;9&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;],
                    [&#34;4&#34;, &#34;5&#34;, &#34;6&#34;, &#34;7&#34;, &#34;8&#34;, &#34;9&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;],
                    [&#34;5&#34;, &#34;6&#34;, &#34;7&#34;, &#34;8&#34;, &#34;9&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;],
                    [&#34;6&#34;, &#34;7&#34;, &#34;8&#34;, &#34;9&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;],
                    [&#34;7&#34;, &#34;8&#34;, &#34;9&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;],
                    [&#34;8&#34;, &#34;9&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;],
                    [&#34;9&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;],
                    [&#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;, &#34;A&#34;]]
                lvlEq = fntom.LevelEquivalence(base62Table = base62Table)

            or it could be initialized by:

                intTable = [
                    [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10],
                    [ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 10],
                    [ 2,  3,  4,  5,  6,  7,  8,  9, 10, 10, 10],
                    [ 3,  4,  5,  6,  7,  8,  9, 10, 10, 10, 10],
                    [ 4,  5,  6,  7,  8,  9, 10, 10, 10, 10, 10],
                    [ 5,  6,  7,  8,  9, 10, 10, 10, 10, 10, 10],
                    [ 6,  7,  8,  9, 10, 10, 10, 10, 10, 10, 10],
                    [ 7,  8,  9, 10, 10, 10, 10, 10, 10, 10, 10],
                    [ 8,  9, 10, 10, 10, 10, 10, 10, 10, 10, 10],
                    [ 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10],
                    [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]]
                lvlEq = fntom.LevelEquivalence(intTable = intTable)

            or it could be initialized by:

                xyzTable = [
                    [&#34;0&#34;, &#34;r&#34;, &#34;s&#34;, &#34;t&#34;, &#34;u&#34;, &#34;v&#34;, &#34;w&#34;, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;, &#34;1&#34;],
                    [&#34;0&#34;, &#34;0&#34;, &#34;r&#34;, &#34;s&#34;, &#34;t&#34;, &#34;u&#34;, &#34;v&#34;, &#34;w&#34;, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;],
                    [&#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;r&#34;, &#34;s&#34;, &#34;t&#34;, &#34;u&#34;, &#34;v&#34;, &#34;w&#34;, &#34;x&#34;, &#34;y&#34;],
                    [&#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;r&#34;, &#34;s&#34;, &#34;t&#34;, &#34;u&#34;, &#34;v&#34;, &#34;w&#34;, &#34;x&#34;],
                    [&#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;r&#34;, &#34;s&#34;, &#34;t&#34;, &#34;u&#34;, &#34;v&#34;, &#34;w&#34;],
                    [&#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;r&#34;, &#34;s&#34;, &#34;t&#34;, &#34;u&#34;, &#34;v&#34;],
                    [&#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;r&#34;, &#34;s&#34;, &#34;t&#34;, &#34;u&#34;],
                    [&#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;r&#34;, &#34;s&#34;, &#34;t&#34;],
                    [&#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;r&#34;, &#34;s&#34;],
                    [&#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;r&#34;]]
                    [&#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;]]
                lvlEq = fntom.LevelEquivalence(xyzTable = xyzTable)

        &#34;&#34;&#34;
        if size != None:
            self.size = size
            self.setDesignatedValues()
            self.eqClasses = self.size * [None]
            for i in range(self.size):
                self.eqClasses[i] = set([])
            # pairs with unit coordinate
            self.eqClasses[self.unit].update(set([(self.unit,self.unit)]))
            for i in range(self.coatom, self.size, 1):
                self.eqClasses[i].update(set([(i,self.unit), (self.unit,i)]))
            # pairs with zero coordinate
            self.eqClasses[self.zero].update(set([(self.zero,self.zero)]))
            for i in range(self.coatom, self.zero, 1):
                self.eqClasses[self.zero].update(set([(i,self.zero), (self.zero,i)]))
            # add all the other pairs - each pair to its own equivalence class
            for i in range(self.coatom, self.zero, 1):
                for j in range(self.coatom, self.zero, 1):
                    self.eqClasses.append(set([(i,j)]))
        elif original != None:
            self.size = original.size
            self.eqClasses = copy.deepcopy(original.eqClasses)
            self.zero = original.zero
            self.unit = original.unit
            self.atom = original.atom
            self.coatom = original.coatom
        elif base62Table != None:
            self.size = len(base62Table)
            self.setDesignatedValues()
            self.eqClasses = self.size * [None]
            for i in range(self.size):
                self.eqClasses[i] = set([])
            for i in range(self.size):
                for j in range(self.size):
                    value = fntom.convertBase62ToDecimal(base62Table[i][j])
                    self.eqClasses[value].add((i, j))
        elif intTable != None:
            self.size = len(intTable)
            self.setDesignatedValues()
            self.eqClasses = self.size * [None]
            for i in range(self.size):
                self.eqClasses[i] = set([])
            for i in range(self.size):
                for j in range(self.size):
                    value = intTable[i][j]
                    self.eqClasses[value].add((i, j))
        elif xyzTable != None:
            self.size = len(xyzTable)
            self.setDesignatedValues()
            self.eqClasses = self.size * [None]
            for i in range(self.size):
                self.eqClasses[i] = set([])
            for i in range(self.size):
                for j in range(self.size):
                    char = xyzTable[i][j]
                    #value = self.getElementCode(char)
                    value = fntom.convert0xyz1ToDecimal(char, self.size)
                    self.eqClasses[value].add((i, self.size - 1 - j))
        else:
            self.size = 1
            self.setDesignatedValues()
            self.eqClasses = [ set([ (self.unit,self.unit) ]) ]

    def setDesignatedValues(self):
        &#34;&#34;&#34;
        According to the value of the attribute `size`, sets the values of
        `zero`, `unit`, `atom`, and `coatom`.
        &#34;&#34;&#34;
        if self.size == 1:
            self.zero = self.unit = self.atom = self.coatom = 0
        else:
            self.zero = self.size - 1
            self.unit = 0
            self.atom = self.size - 2
            self.coatom = 1

    def getCopy(self):
        &#34;&#34;&#34;
            Returns:
                LevelEquivalence: a deep copy of this instance
        &#34;&#34;&#34;
        return LevelEquivalence(original = self)

    def findIdempotents(self):
        &#34;&#34;&#34;
        Finds and returns all the non-trivial idempotents.

        An element x is an idempotent if x*x=x (where * is the monoidal
            operation).

        Hence if an equivalence class indexed by x that contains the pair (x,x)
        is found then the value x is an idempotent.

        Note that the top element 1 and the bottom element 0 is an idempotent
        of every f. n. tomonoid; these values are called trivial idempotents.
        These values are not included in the returned list of idempotents.

        Returns:
            list of int: list of the non-trivial idempotents
        &#34;&#34;&#34;
        idempotents = []
        for x in range(self.coatom, self.zero, 1):
            if self.getValue((x,x)) == x:
                idempotents.append(x)
        return idempotents

    def performZeroDoublingExtension(self):
        &#34;&#34;&#34;
        Performs the zero-doubling extension on this tomonoid.

          * Removes all the pairs from the level set equivalence that are
            equivalent with (0, 1) and (1, 0).
          * Enlarges the size of the tomonoid by one adding a new bottom
            element.
          * Recomputes the values of `zero`, `unit`, `atom`, and `coatom`.
        &#34;&#34;&#34;
        formerSize = self.size

        self.size += 1
        self.setDesignatedValues()

        numEqClasses = len(self.eqClasses)
        if numEqClasses &gt; formerSize:
            # move the last class behind former zero to the end of the list
            self.eqClasses.append(self.eqClasses[self.zero])
            # add (1,0), (0,1), and (0,0) to the zero class
            self.eqClasses[self.zero] = set([(self.unit, self.zero), (self.zero, self.unit), (self.zero, self.zero)])
        else:
            # add (1,0), (0,1), and (0,0) to the zero class
            self.eqClasses.append(set([(self.unit, self.zero), (self.zero, self.unit), (self.zero, self.zero)]))

        # add pairs of type (x,0) and (0,x) to the zero class
        for i in range(self.coatom, self.zero, 1):
            self.eqClasses[self.zero].add((self.zero,i))
            self.eqClasses[self.zero].add((i,self.zero))

        # atom class (former zero class) is used to determine all the single
        # pair undefined equivalence classes
        if self.size &gt; 2:
            for pair in self.eqClasses[self.atom]:
                if self.isNotOnBorder(pair):
                    self.eqClasses.append(set([pair]))

        # setting the atom class to (1,at)~(at,1)
        self.eqClasses[self.atom] = set([(self.unit, self.atom), (self.atom, self.unit)])

    def findEqClass(self, pair):
        &#34;&#34;&#34;
        Finds the class to which the given pair belongs.

        Args:
            pair (2-tuple of int): the searched pair

        Returns:
            2-tuple: `(class, index)` where `class` is the reference to the
                class containing the `pair` while `index` is the index in the
                list `eqClasses`

        Raises:
            Exception: if the pair has not been found
        &#34;&#34;&#34;
        numEqClasses = len(self.eqClasses)
        for i in range(numEqClasses):
            if pair in self.eqClasses[i]:
                return (self.eqClasses[i], i)
        raise Exception(&#34;ERROR: Pair&#34;, pair, &#34;has not been found&#34;)

    def isElement(self, value):
        &#34;&#34;&#34;
        Args:
            value (int): index of level equivalence class in `eqClasses`

        Returns:
            bool: `True` if `value` is an element of the monoid
        &#34;&#34;&#34;
        return self.unit &lt;= value &lt;= self.zero

    def isAtomOrHigher(self, value):
        &#34;&#34;&#34;
        Args:
            value (int): index of level equivalence class in `eqClasses`

        Returns:
            bool: `True` if `value` is an element of the monoid that is not
                equal to `zero`
        &#34;&#34;&#34;
        return self.unit &lt;= value &lt; self.zero

    def isHigherThanAtom(self, value):
        &#34;&#34;&#34;
        Args:
            value (int): index of level equivalence class in `eqClasses`

        Returns:
            bool: `True` if `value` is an element of the monoid that is neither
                equal to `zero` nor to `atom`
        &#34;&#34;&#34;
        return self.isElement(value) and value &lt; self.atom

    def isZeroOrAtomOrNotElement(self, value):
        &#34;&#34;&#34;
        Args:
            value (int): index of level equivalence class in `eqClasses`

        Returns:
            bool: `True` if `value` is equal to `zero` or to `atom` or if it is
                not an element of the monoid
        &#34;&#34;&#34;
        return value == self.zero or value == self.atom or not self.isElement(value)

    def isAtomOrNotElement(self, value):
        &#34;&#34;&#34;
        Args:
            value (int): index of level equivalence class in `eqClasses`

        Returns:
            bool: `True` if `value` is equal to `atom` or if it is not an
                element of the monoid
        &#34;&#34;&#34;
        return value == self.atom or not self.isElement(value)

    def isNotOnBorder(self, pair):
        &#34;&#34;&#34;
        Args:
            value (2-tuple of int): pair of monoid elements

        Returns:
            bool: `True` if the pair does lie neither on the axis given by the
                zero element nor on the axis given by the unit element
        &#34;&#34;&#34;
        return self.zero &gt; pair[0] &gt; self.unit and self.zero &gt; pair[1] &gt; self.unit

    def setValue(self, pair, value):
        &#34;&#34;&#34;
        Defines the value to which the given pair is supposed to be evaluated
        by the monoidal operation.

        It, actually, merges (relates) the class that contains `pair` with the
        class that contains the pairs `(1,value)` and `(value,1)`.

        Args:
            pair (2-tuple of int): the pair
            value (int): to which value is the pair supposed to be evaluated
                (the index of the class)
        &#34;&#34;&#34;
        (cla, ind) = self.findEqClass(pair)
        if ind != value:
            if self.isElement(ind):
                raise fntom.Error.NotTOMPartition([ind, value], self)
            else:
                self.eqClasses[value].update(cla)
                self.eqClasses.remove(cla)

    def getValue(self, pair):
        &#34;&#34;&#34;
        Returns the value of the given pair according to the monoidal
        operation.

        A value outside of the range of the monoidal values may be returned if
        the pair belongs to a class that does not contain pairs of the type
        `(1,x)`, `(x,1)`.

        Args:
            pair (2-tuple of int): the pair

        Returns:
            int: the value of the pair according to the monoidal operation
                (i.e., the index of the level equivalence class to which the
                pair belongs)
        &#34;&#34;&#34;
        (cla, ind) = self.findEqClass(pair)
        return ind

    def relateClasses(self, ind1, ind2):
        &#34;&#34;&#34;
        Merges two level equivalence classes into one.

        Args:
            ind1 (int): index of the first class in `eqClasses`
            ind2 (int): index of the second class in `eqClasses`

        Raises:
            fntom.Error.NotTOMPartition: if both the classes contain pairs of
                the types (1,x) and (x,1)
        &#34;&#34;&#34;
        if ind1 != ind2:
            if self.isElement(ind2):
                if self.isElement(ind1):
                    raise fntom.Error.NotTOMPartition([ind1, ind2], self)
                else:
                    self.eqClasses[ind2].update(self.eqClasses[ind1])
                    self.eqClasses.remove(self.eqClasses[ind1])
            else:
                self.eqClasses[ind1].update(self.eqClasses[ind2])
                self.eqClasses.remove(self.eqClasses[ind2])

    #TODO !!! neni resen pripad, kdy pair1 nebo pair2 neni v zadne tride
    def relatePairs(self, pair1, pair2):
        &#34;&#34;&#34;
        Merges the level equivalence classes that contain the given pairs.

        Args:
            pair1 (2-tuple of int): first pair
            pair2 (2-tuple of int): second pair

        Raises:
            fntom.Error.NotTOMPartition: if both the classes contain pairs of
                the types (1,x) and (x,1)
        &#34;&#34;&#34;
        if pair1 != pair2:
            (cla1, ind1) = self.findEqClass(pair1)
            (cla2, ind2) = self.findEqClass(pair2)
            self.relateClasses(ind1, ind2)

    def setPairToZero(self, pair):
        &#34;&#34;&#34;
        Adds the given pair to the zero equivalence class.

        Merges the class that contains the pair with the class that contains
        (1,0) and (0,1).
        Furthermore, the monotonicity of the tomonoid is taken into account,
        i.e., all the pairs that are closer to (0,0) are added to the zero
        equivalence class, as well.

        Args:
            pair (2-tuple of int): the pair that is to be evaluated to zero by
                the monoidal operation
        &#34;&#34;&#34;
        if self.isNotOnBorder(pair):
            for i in range(pair[0], self.zero, 1):
                for j in range(pair[1], self.zero, 1):
                    (cla, ind) = self.findEqClass(pair)
                    self.mergeEqClassWithZero(ind)

    def mergeEqClassWithZero(self, ind):
        &#34;&#34;&#34;
        Merges the given level equivalence class with the zero equivalence
            class.

        Merges the given class with the class that contains (1,0) and (0,1).
        Furthermore, the monotonicity of the tomonoid is taken into account,
        i.e., all the pairs that are closer to (0,0) (compared to the pairs of
        the given class) are added to the zero equivalence class, as well.

        Args:
            ind (int): index of the class in `eqClasses`

        Raises:
            fntom.Error.NotTOMPartition: if both the classes contain pairs of
                the types (1,x) and (x,1)
        &#34;&#34;&#34;
        if not self.isElement(ind):
            cla = self.eqClasses[ind]
            self.eqClasses[self.zero].update(cla)
            self.eqClasses.remove(cla)
            for pair in cla:
                self.setPairToZero((pair[0]+1,pair[1]))
                self.setPairToZero((pair[0],pair[1]+1))
        elif self.isAtomOrHigher(ind):
            raise fntom.Error.NotTOMPartition([self.zero, ind], self)

    def setPairToAtom(self, pair):
        &#34;&#34;&#34;
        Adds the given pair to the atom equivalence class.

        Merges the class that contains the pair with the class that contains
        (1,atom) and (atom,1).
        Furthermore, the monotonicity of the tomonoid is taken into account,
        i.e., all the pairs that are closer to (1,1) are added to the atom
        equivalence class, as well.

        Args:
            pair (2-tuple of int): the pair that is to be evaluated to atom by
                the monoidal operation
        &#34;&#34;&#34;
        if self.isNotOnBorder(pair):
            for i in range(pair[0], self.unit, -1):
                for j in range(pair[1], self.unit, -1):
                    (cla, ind) = self.findEqClass(pair)
                    self.mergeEqClassWithAtom(ind)

    def mergeEqClassWithAtom(self, ind):
        &#34;&#34;&#34;
        Merges the given level equivalence class with the atom equivalence
            class.

        Merges the given class with the class that contains (1,atom) and (atom,1).
        Furthermore, the monotonicity of the tomonoid is taken into account,
        i.e., all the pairs that are closer to (1,1) (compared to the pairs of
        the given class) are added to the atom equivalence class, as well.

        Args:
            ind (int): index of the class in `eqClasses`

        Raises:
            fntom.Error.NotTOMPartition: if both the classes contain pairs of
                the types (1,x) and (x,1)
        &#34;&#34;&#34;
        if not self.isElement(ind):
            cla = self.eqClasses[ind]
            self.eqClasses[self.atom].update(cla)
            self.eqClasses.remove(cla)
            for pair in cla:
                self.setPairToAtom((pair[0]-1,pair[1]))
                self.setPairToAtom((pair[0],pair[1]-1))
        elif ind == self.zero:
            raise fntom.Error.NotTOMPartition([self.zero, self.atom], self)

    def setRestToZero(self):
        &#34;&#34;&#34;
        Sets all the undetermined pairs to zero.

        Undetermined pairs are those that are contained in the equivalence
        classes with their indices out of the range of the tomonoid values.
        &#34;&#34;&#34;
        numClasses = len(self.eqClasses)
        for ind in range(numClasses - 1, self.size - 1, -1):
            self.relateClasses(ind, self.zero)

    def relateColumn(self, x, yFrom, yTo):
        &#34;&#34;&#34;
        Makes the pairs in a bounded column of the Cayley table level
        equivalent.

        This involves the pairs in the range from `(x, yFrom)` to `(x, yTo)`.

        The value of `yFrom` does not need to be lower than `yTo` (or vice
        versa).

        Args:
            x (int): an element of the monoid
            yFrom (int): an element of the monoid
            yTo (int): an element of the monoid
        &#34;&#34;&#34;
        if yFrom == yTo:
            return
        elif yFrom &lt; yTo:
            rang = range(yFrom, yTo+1, 1)
        elif yFrom &gt; yTo:
            rang = range(yTo, yFrom+1, 1)
        first = None
        for y in rang:
            if first == None:
                first = (x,y)
            else:
                self.relatePairs(first, (x,y))

    def relateRow(self, xFrom, xTo, y):
        &#34;&#34;&#34;
        Makes the pairs in a bounded row of the Cayley table level equivalent.

        This involves the pairs in the range from `(xFrom, y)` to `(xTo, y)`.

        The value of `xFrom` does not need to be lower than `xTo` (or vice
        versa).

        Args:
            xFrom (int): an element of the monoid
            xTo (int): an element of the monoid
            y (int): an element of the monoid
        &#34;&#34;&#34;
        if xFrom == xTo:
            return
        elif xFrom &lt; xTo:
            ran = range(xFrom, xTo+1, 1)
        elif xFrom &gt; xTo:
            ran = range(xTo, xFrom+1, 1)
        first = None
        for x in ran:
            if first == None:
                first = (x,y)
            else:
                self.relatePairs(first, (x,y))

    def getTable(self):
        &#34;&#34;&#34;
        Constructs the Cayley table of the tomonoid.

        The table is constructed according to the level set equivalence.

        Returns:
            list of list of int: the Cayley table
        &#34;&#34;&#34;
        table = []
        for i in range(self.size):
            table.append(self.size * [-1])
        for eqClassIndex in range(len(self.eqClasses)):
            for pair in self.eqClasses[eqClassIndex]:
                (i, j) = pair
                table[i][j] = eqClassIndex
        return table

    def performAssociativityTest(self):
        &#34;&#34;&#34;
        Tests whether the operaration defined by the level set equivalence is
        associative.

        Returns:
            3-tuple of int: `None` if it is associative, `(x, y, z)` if it is
                not associative; the triplet `(x, y, z)` contains the values on
                which the associativity test has failed
        &#34;&#34;&#34;
        table = self.getTable()
        for x in range(self.size):
            for y in range(self.size):
                for z in range(self.size):
                    xy = table[x][y]
                    yz = table[y][z]
                    if table[xy][z] != table[x][yz]:
                        return (x, y, z)
        return None

    def performMonotonicityTest(self):
        &#34;&#34;&#34;
        Tests whether the operaration defined by the level set equivalence is
        monotone.

        Returns:
            2-tuple of int: `None` if it is monotone, `(x, y)` if it is not
                monotone; the pair `(x, y)` contains the values on which the
                monotonicity test has failed
        &#34;&#34;&#34;
        table = self.getTable()
        for x in range(0, self.size-1, 1):
            for y in range(0, self.size-1, 1):
                if table[x+1][y] &lt; table[x][y] or table[x][y+1] &lt; table[x][y]:
                    return (x, y)
        return None

    def performArchimedeanicityTest(self):
        &#34;&#34;&#34;
        Tests whether the operaration defined by the level set equivalence is
        Archimedean.

        Returns:
            int: `None` if it is Archimedean, a single integer value if it is
                not Archimedean; the value is one of the non-trivial idempotents of
                the monoid
        &#34;&#34;&#34;
        table = self.getTable()
        for x in range(1, self.size-1, 1):
            if table[x][x] &lt;= x:
                return x
        return None

    def performCommutativityTest(self):
        &#34;&#34;&#34;
        Tests whether the operaration defined by the level set equivalence is
        commutative.

        Returns:
            2-tuple of int: `None` if it is commutative, `(x, y)` if it is not
                commutative; the pair `(x, y)` contains the values on which the
                commutativity test has failed
        &#34;&#34;&#34;
        table = self.getTable()
        for x in range(self.size):
            for y in range(self.size):
                if table[x][y] != table[y][x]:
                    return (x, y)
        return None

    def exportClassesToText(self):
        &#34;&#34;&#34;
        Returns:
            str: description of the level equivalence classes; suitable to be
                printed to the terminal output
        &#34;&#34;&#34;
        text = &#34;&#34;
        numClasses = len(self.eqClasses)
        for i in range(numClasses):
            textPart = str(i) + &#34;: &#34;
            initialLength = len(textPart)
            lineLength = initialLength
            text += textPart
            first = True
            for (a, b) in self.eqClasses[i]:
                if first:
                    first = False
                else:
                    text += &#34; &#34;
                    lineLength += 1
                textPart = &#34;(&#34; + str(a) + &#34;,&#34; + str(b) + &#34;)&#34;
                if lineLength + len(textPart) &gt; 78:
                    text += &#34;\n&#34;
                    text += initialLength * &#34; &#34;
                    text += textPart
                    lineLength = initialLength + len(textPart)
                else:
                    text += textPart
                    lineLength += len(textPart)

            text += &#34;\n&#34;
        return text

    def exportTableToText(self, separator = &#34;, &#34;, endLine = &#34;\n&#34;, tableSymbols = &#34;base62&#34;):
        &#34;&#34;&#34;
        Args:
            separator (str, optional): string that separates the values in the
                table

            endLine (str, optional): string that separates the rows of the
                table

            tableSymbols (str, optional): one of the following three values:

                * &#34;base62&#34; (default) ... the element of the tomonoid will be
                    diplayed as symbls from the number system 62, that is, the
                    characters from
                    `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`
                    where `0` represents the neutral element (unit)
                * &#34;int&#34; ... the element of the tomonoid will be diplayed as
                    non-negative integers starting from `0` which will represent
                    the neutral element (unit)
                * &#34;0xyz1&#34; ...  the element of the tomonoid will be diplayed as
                    the characters from the set:
                    `&#34;0&#34;`, ..., `&#34;x&#34;`, `&#34;y&#34;`, `&#34;z&#34;`, `&#34;1&#34;`
                    In this case, the table will be left-right flipped
                    (according to the vertical axis).
                    This style of depicting the Cayley table corresponds with
                    the style used in the referenced papers
                    [PeVe14,PeVe16,PeVe17,PeVe19], while the previous two
                    styles reflect the inner representation of the tomonoid.

        Returns:
            str: Cayley table of the monoid;
                suitable be written to a text file or to the terminal output
        &#34;&#34;&#34;
        table = self.getTable()
        text = &#34;&#34;
        if tableSymbols == &#34;int&#34;:
            width = len(str(len(self.eqClasses) - 1))
        else:
            width = 1
        for i in range(self.size):
            if i &gt; 0:
                text += endLine
            first = True
            for j in range(self.size):
                if first:
                    first = False
                else:
                    text += separator
                if tableSymbols == &#34;0xyz1&#34;:
                    value = table[i][self.size - 1 - j]
                else:
                    value = table[i][j]
                if tableSymbols == &#34;base62&#34;:
                    if value == None:
                        text += &#34;?&#34;
                    else:
                        text += fntom.convertDecimalToBase62(value)
                elif tableSymbols == &#34;int&#34;:
                    text += f&#39;{value:&gt;{width}}&#39;
                elif tableSymbols == &#34;0xyz1&#34;:
                    text += fntom.convertDecimalTo0xyz1(value, self.size)
        return text

    def show(self):
        &#34;&#34;&#34;
        Prints the values of the attributes of this instance to the terminal
            output.

        Mostly for debugging purposes.
        &#34;&#34;&#34;
        print(self.exportTableToText())
        print(self.exportClassesToText())</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fntom.FNTOMonoid.FNTOMonoid" href="FNTOMonoid.html#fntom.FNTOMonoid.FNTOMonoid">FNTOMonoid</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fntom.LevelEquivalence.LevelEquivalence.exportClassesToText"><code class="name flex">
<span>def <span class="ident">exportClassesToText</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>description of the level equivalence classes; suitable to be
printed to the terminal output</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exportClassesToText(self):
    &#34;&#34;&#34;
    Returns:
        str: description of the level equivalence classes; suitable to be
            printed to the terminal output
    &#34;&#34;&#34;
    text = &#34;&#34;
    numClasses = len(self.eqClasses)
    for i in range(numClasses):
        textPart = str(i) + &#34;: &#34;
        initialLength = len(textPart)
        lineLength = initialLength
        text += textPart
        first = True
        for (a, b) in self.eqClasses[i]:
            if first:
                first = False
            else:
                text += &#34; &#34;
                lineLength += 1
            textPart = &#34;(&#34; + str(a) + &#34;,&#34; + str(b) + &#34;)&#34;
            if lineLength + len(textPart) &gt; 78:
                text += &#34;\n&#34;
                text += initialLength * &#34; &#34;
                text += textPart
                lineLength = initialLength + len(textPart)
            else:
                text += textPart
                lineLength += len(textPart)

        text += &#34;\n&#34;
    return text</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.exportTableToText"><code class="name flex">
<span>def <span class="ident">exportTableToText</span></span>(<span>self, separator=', ', endLine='\n', tableSymbols='base62')</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>separator</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>string that separates the values in the
table</dd>
<dt><strong><code>endLine</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>string that separates the rows of the
table</dd>
<dt><strong><code>tableSymbols</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>
<p>one of the following three values:</p>
<ul>
<li>"base62" (default) &hellip; the element of the tomonoid will be
diplayed as symbls from the number system 62, that is, the
characters from
<code>0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</code>
where <code>0</code> represents the neutral element (unit)</li>
<li>"int" &hellip; the element of the tomonoid will be diplayed as
non-negative integers starting from <code>0</code> which will represent
the neutral element (unit)</li>
<li>"0xyz1" &hellip;
the element of the tomonoid will be diplayed as
the characters from the set:
<code>"0"</code>, &hellip;, <code>"x"</code>, <code>"y"</code>, <code>"z"</code>, <code>"1"</code>
In this case, the table will be left-right flipped
(according to the vertical axis).
This style of depicting the Cayley table corresponds with
the style used in the referenced papers
[PeVe14,PeVe16,PeVe17,PeVe19], while the previous two
styles reflect the inner representation of the tomonoid.</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Cayley table of the monoid;
suitable be written to a text file or to the terminal output</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exportTableToText(self, separator = &#34;, &#34;, endLine = &#34;\n&#34;, tableSymbols = &#34;base62&#34;):
    &#34;&#34;&#34;
    Args:
        separator (str, optional): string that separates the values in the
            table

        endLine (str, optional): string that separates the rows of the
            table

        tableSymbols (str, optional): one of the following three values:

            * &#34;base62&#34; (default) ... the element of the tomonoid will be
                diplayed as symbls from the number system 62, that is, the
                characters from
                `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`
                where `0` represents the neutral element (unit)
            * &#34;int&#34; ... the element of the tomonoid will be diplayed as
                non-negative integers starting from `0` which will represent
                the neutral element (unit)
            * &#34;0xyz1&#34; ...  the element of the tomonoid will be diplayed as
                the characters from the set:
                `&#34;0&#34;`, ..., `&#34;x&#34;`, `&#34;y&#34;`, `&#34;z&#34;`, `&#34;1&#34;`
                In this case, the table will be left-right flipped
                (according to the vertical axis).
                This style of depicting the Cayley table corresponds with
                the style used in the referenced papers
                [PeVe14,PeVe16,PeVe17,PeVe19], while the previous two
                styles reflect the inner representation of the tomonoid.

    Returns:
        str: Cayley table of the monoid;
            suitable be written to a text file or to the terminal output
    &#34;&#34;&#34;
    table = self.getTable()
    text = &#34;&#34;
    if tableSymbols == &#34;int&#34;:
        width = len(str(len(self.eqClasses) - 1))
    else:
        width = 1
    for i in range(self.size):
        if i &gt; 0:
            text += endLine
        first = True
        for j in range(self.size):
            if first:
                first = False
            else:
                text += separator
            if tableSymbols == &#34;0xyz1&#34;:
                value = table[i][self.size - 1 - j]
            else:
                value = table[i][j]
            if tableSymbols == &#34;base62&#34;:
                if value == None:
                    text += &#34;?&#34;
                else:
                    text += fntom.convertDecimalToBase62(value)
            elif tableSymbols == &#34;int&#34;:
                text += f&#39;{value:&gt;{width}}&#39;
            elif tableSymbols == &#34;0xyz1&#34;:
                text += fntom.convertDecimalTo0xyz1(value, self.size)
    return text</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.findEqClass"><code class="name flex">
<span>def <span class="ident">findEqClass</span></span>(<span>self, pair)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the class to which the given pair belongs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pair</code></strong> :&ensp;<code>2-tuple</code> of <code>int</code></dt>
<dd>the searched pair</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>2-tuple: <code>(class, index)</code> where <code>class</code> is the reference to the
class containing the <code>pair</code> while <code>index</code> is the index in the
list <code>eqClasses</code></p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>if the pair has not been found</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findEqClass(self, pair):
    &#34;&#34;&#34;
    Finds the class to which the given pair belongs.

    Args:
        pair (2-tuple of int): the searched pair

    Returns:
        2-tuple: `(class, index)` where `class` is the reference to the
            class containing the `pair` while `index` is the index in the
            list `eqClasses`

    Raises:
        Exception: if the pair has not been found
    &#34;&#34;&#34;
    numEqClasses = len(self.eqClasses)
    for i in range(numEqClasses):
        if pair in self.eqClasses[i]:
            return (self.eqClasses[i], i)
    raise Exception(&#34;ERROR: Pair&#34;, pair, &#34;has not been found&#34;)</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.findIdempotents"><code class="name flex">
<span>def <span class="ident">findIdempotents</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds and returns all the non-trivial idempotents.</p>
<p>An element x is an idempotent if x*x=x (where * is the monoidal
operation).</p>
<p>Hence if an equivalence class indexed by x that contains the pair (x,x)
is found then the value x is an idempotent.</p>
<p>Note that the top element 1 and the bottom element 0 is an idempotent
of every f. n. tomonoid; these values are called trivial idempotents.
These values are not included in the returned list of idempotents.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>int</code></dt>
<dd>list of the non-trivial idempotents</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findIdempotents(self):
    &#34;&#34;&#34;
    Finds and returns all the non-trivial idempotents.

    An element x is an idempotent if x*x=x (where * is the monoidal
        operation).

    Hence if an equivalence class indexed by x that contains the pair (x,x)
    is found then the value x is an idempotent.

    Note that the top element 1 and the bottom element 0 is an idempotent
    of every f. n. tomonoid; these values are called trivial idempotents.
    These values are not included in the returned list of idempotents.

    Returns:
        list of int: list of the non-trivial idempotents
    &#34;&#34;&#34;
    idempotents = []
    for x in range(self.coatom, self.zero, 1):
        if self.getValue((x,x)) == x:
            idempotents.append(x)
    return idempotents</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.getCopy"><code class="name flex">
<span>def <span class="ident">getCopy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="fntom.LevelEquivalence.LevelEquivalence" href="#fntom.LevelEquivalence.LevelEquivalence">LevelEquivalence</a></code></dt>
<dd>a deep copy of this instance</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCopy(self):
    &#34;&#34;&#34;
        Returns:
            LevelEquivalence: a deep copy of this instance
    &#34;&#34;&#34;
    return LevelEquivalence(original = self)</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.getTable"><code class="name flex">
<span>def <span class="ident">getTable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Constructs the Cayley table of the tomonoid.</p>
<p>The table is constructed according to the level set equivalence.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>list</code> of <code>int</code></dt>
<dd>the Cayley table</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTable(self):
    &#34;&#34;&#34;
    Constructs the Cayley table of the tomonoid.

    The table is constructed according to the level set equivalence.

    Returns:
        list of list of int: the Cayley table
    &#34;&#34;&#34;
    table = []
    for i in range(self.size):
        table.append(self.size * [-1])
    for eqClassIndex in range(len(self.eqClasses)):
        for pair in self.eqClasses[eqClassIndex]:
            (i, j) = pair
            table[i][j] = eqClassIndex
    return table</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.getValue"><code class="name flex">
<span>def <span class="ident">getValue</span></span>(<span>self, pair)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the value of the given pair according to the monoidal
operation.</p>
<p>A value outside of the range of the monoidal values may be returned if
the pair belongs to a class that does not contain pairs of the type
<code>(1,x)</code>, <code>(x,1)</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pair</code></strong> :&ensp;<code>2-tuple</code> of <code>int</code></dt>
<dd>the pair</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>the value of the pair according to the monoidal operation
(i.e., the index of the level equivalence class to which the
pair belongs)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getValue(self, pair):
    &#34;&#34;&#34;
    Returns the value of the given pair according to the monoidal
    operation.

    A value outside of the range of the monoidal values may be returned if
    the pair belongs to a class that does not contain pairs of the type
    `(1,x)`, `(x,1)`.

    Args:
        pair (2-tuple of int): the pair

    Returns:
        int: the value of the pair according to the monoidal operation
            (i.e., the index of the level equivalence class to which the
            pair belongs)
    &#34;&#34;&#34;
    (cla, ind) = self.findEqClass(pair)
    return ind</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.isAtomOrHigher"><code class="name flex">
<span>def <span class="ident">isAtomOrHigher</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>index of level equivalence class in <code>eqClasses</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if <code>value</code> is an element of the monoid that is not
equal to <code>zero</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isAtomOrHigher(self, value):
    &#34;&#34;&#34;
    Args:
        value (int): index of level equivalence class in `eqClasses`

    Returns:
        bool: `True` if `value` is an element of the monoid that is not
            equal to `zero`
    &#34;&#34;&#34;
    return self.unit &lt;= value &lt; self.zero</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.isAtomOrNotElement"><code class="name flex">
<span>def <span class="ident">isAtomOrNotElement</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>index of level equivalence class in <code>eqClasses</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if <code>value</code> is equal to <code>atom</code> or if it is not an
element of the monoid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isAtomOrNotElement(self, value):
    &#34;&#34;&#34;
    Args:
        value (int): index of level equivalence class in `eqClasses`

    Returns:
        bool: `True` if `value` is equal to `atom` or if it is not an
            element of the monoid
    &#34;&#34;&#34;
    return value == self.atom or not self.isElement(value)</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.isElement"><code class="name flex">
<span>def <span class="ident">isElement</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>index of level equivalence class in <code>eqClasses</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if <code>value</code> is an element of the monoid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isElement(self, value):
    &#34;&#34;&#34;
    Args:
        value (int): index of level equivalence class in `eqClasses`

    Returns:
        bool: `True` if `value` is an element of the monoid
    &#34;&#34;&#34;
    return self.unit &lt;= value &lt;= self.zero</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.isHigherThanAtom"><code class="name flex">
<span>def <span class="ident">isHigherThanAtom</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>index of level equivalence class in <code>eqClasses</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if <code>value</code> is an element of the monoid that is neither
equal to <code>zero</code> nor to <code>atom</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isHigherThanAtom(self, value):
    &#34;&#34;&#34;
    Args:
        value (int): index of level equivalence class in `eqClasses`

    Returns:
        bool: `True` if `value` is an element of the monoid that is neither
            equal to `zero` nor to `atom`
    &#34;&#34;&#34;
    return self.isElement(value) and value &lt; self.atom</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.isNotOnBorder"><code class="name flex">
<span>def <span class="ident">isNotOnBorder</span></span>(<span>self, pair)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>2-tuple</code> of <code>int</code></dt>
<dd>pair of monoid elements</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if the pair does lie neither on the axis given by the
zero element nor on the axis given by the unit element</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isNotOnBorder(self, pair):
    &#34;&#34;&#34;
    Args:
        value (2-tuple of int): pair of monoid elements

    Returns:
        bool: `True` if the pair does lie neither on the axis given by the
            zero element nor on the axis given by the unit element
    &#34;&#34;&#34;
    return self.zero &gt; pair[0] &gt; self.unit and self.zero &gt; pair[1] &gt; self.unit</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.isZeroOrAtomOrNotElement"><code class="name flex">
<span>def <span class="ident">isZeroOrAtomOrNotElement</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>index of level equivalence class in <code>eqClasses</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if <code>value</code> is equal to <code>zero</code> or to <code>atom</code> or if it is
not an element of the monoid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isZeroOrAtomOrNotElement(self, value):
    &#34;&#34;&#34;
    Args:
        value (int): index of level equivalence class in `eqClasses`

    Returns:
        bool: `True` if `value` is equal to `zero` or to `atom` or if it is
            not an element of the monoid
    &#34;&#34;&#34;
    return value == self.zero or value == self.atom or not self.isElement(value)</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.mergeEqClassWithAtom"><code class="name flex">
<span>def <span class="ident">mergeEqClassWithAtom</span></span>(<span>self, ind)</span>
</code></dt>
<dd>
<div class="desc"><p>Merges the given level equivalence class with the atom equivalence
class.</p>
<p>Merges the given class with the class that contains (1,atom) and (atom,1).
Furthermore, the monotonicity of the tomonoid is taken into account,
i.e., all the pairs that are closer to (1,1) (compared to the pairs of
the given class) are added to the atom equivalence class, as well.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ind</code></strong> :&ensp;<code>int</code></dt>
<dd>index of the class in <code>eqClasses</code></dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fntom.Error.NotTOMPartition" href="Error.html#fntom.Error.NotTOMPartition">NotTOMPartition</a></code></dt>
<dd>if both the classes contain pairs of
the types (1,x) and (x,1)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mergeEqClassWithAtom(self, ind):
    &#34;&#34;&#34;
    Merges the given level equivalence class with the atom equivalence
        class.

    Merges the given class with the class that contains (1,atom) and (atom,1).
    Furthermore, the monotonicity of the tomonoid is taken into account,
    i.e., all the pairs that are closer to (1,1) (compared to the pairs of
    the given class) are added to the atom equivalence class, as well.

    Args:
        ind (int): index of the class in `eqClasses`

    Raises:
        fntom.Error.NotTOMPartition: if both the classes contain pairs of
            the types (1,x) and (x,1)
    &#34;&#34;&#34;
    if not self.isElement(ind):
        cla = self.eqClasses[ind]
        self.eqClasses[self.atom].update(cla)
        self.eqClasses.remove(cla)
        for pair in cla:
            self.setPairToAtom((pair[0]-1,pair[1]))
            self.setPairToAtom((pair[0],pair[1]-1))
    elif ind == self.zero:
        raise fntom.Error.NotTOMPartition([self.zero, self.atom], self)</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.mergeEqClassWithZero"><code class="name flex">
<span>def <span class="ident">mergeEqClassWithZero</span></span>(<span>self, ind)</span>
</code></dt>
<dd>
<div class="desc"><p>Merges the given level equivalence class with the zero equivalence
class.</p>
<p>Merges the given class with the class that contains (1,0) and (0,1).
Furthermore, the monotonicity of the tomonoid is taken into account,
i.e., all the pairs that are closer to (0,0) (compared to the pairs of
the given class) are added to the zero equivalence class, as well.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ind</code></strong> :&ensp;<code>int</code></dt>
<dd>index of the class in <code>eqClasses</code></dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fntom.Error.NotTOMPartition" href="Error.html#fntom.Error.NotTOMPartition">NotTOMPartition</a></code></dt>
<dd>if both the classes contain pairs of
the types (1,x) and (x,1)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mergeEqClassWithZero(self, ind):
    &#34;&#34;&#34;
    Merges the given level equivalence class with the zero equivalence
        class.

    Merges the given class with the class that contains (1,0) and (0,1).
    Furthermore, the monotonicity of the tomonoid is taken into account,
    i.e., all the pairs that are closer to (0,0) (compared to the pairs of
    the given class) are added to the zero equivalence class, as well.

    Args:
        ind (int): index of the class in `eqClasses`

    Raises:
        fntom.Error.NotTOMPartition: if both the classes contain pairs of
            the types (1,x) and (x,1)
    &#34;&#34;&#34;
    if not self.isElement(ind):
        cla = self.eqClasses[ind]
        self.eqClasses[self.zero].update(cla)
        self.eqClasses.remove(cla)
        for pair in cla:
            self.setPairToZero((pair[0]+1,pair[1]))
            self.setPairToZero((pair[0],pair[1]+1))
    elif self.isAtomOrHigher(ind):
        raise fntom.Error.NotTOMPartition([self.zero, ind], self)</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.performArchimedeanicityTest"><code class="name flex">
<span>def <span class="ident">performArchimedeanicityTest</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether the operaration defined by the level set equivalence is
Archimedean.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd><code>None</code> if it is Archimedean, a single integer value if it is
not Archimedean; the value is one of the non-trivial idempotents of
the monoid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def performArchimedeanicityTest(self):
    &#34;&#34;&#34;
    Tests whether the operaration defined by the level set equivalence is
    Archimedean.

    Returns:
        int: `None` if it is Archimedean, a single integer value if it is
            not Archimedean; the value is one of the non-trivial idempotents of
            the monoid
    &#34;&#34;&#34;
    table = self.getTable()
    for x in range(1, self.size-1, 1):
        if table[x][x] &lt;= x:
            return x
    return None</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.performAssociativityTest"><code class="name flex">
<span>def <span class="ident">performAssociativityTest</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether the operaration defined by the level set equivalence is
associative.</p>
<h2 id="returns">Returns</h2>
<p>3-tuple of int: <code>None</code> if it is associative, <code>(x, y, z)</code> if it is
not associative; the triplet <code>(x, y, z)</code> contains the values on
which the associativity test has failed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def performAssociativityTest(self):
    &#34;&#34;&#34;
    Tests whether the operaration defined by the level set equivalence is
    associative.

    Returns:
        3-tuple of int: `None` if it is associative, `(x, y, z)` if it is
            not associative; the triplet `(x, y, z)` contains the values on
            which the associativity test has failed
    &#34;&#34;&#34;
    table = self.getTable()
    for x in range(self.size):
        for y in range(self.size):
            for z in range(self.size):
                xy = table[x][y]
                yz = table[y][z]
                if table[xy][z] != table[x][yz]:
                    return (x, y, z)
    return None</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.performCommutativityTest"><code class="name flex">
<span>def <span class="ident">performCommutativityTest</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether the operaration defined by the level set equivalence is
commutative.</p>
<h2 id="returns">Returns</h2>
<p>2-tuple of int: <code>None</code> if it is commutative, <code>(x, y)</code> if it is not
commutative; the pair <code>(x, y)</code> contains the values on which the
commutativity test has failed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def performCommutativityTest(self):
    &#34;&#34;&#34;
    Tests whether the operaration defined by the level set equivalence is
    commutative.

    Returns:
        2-tuple of int: `None` if it is commutative, `(x, y)` if it is not
            commutative; the pair `(x, y)` contains the values on which the
            commutativity test has failed
    &#34;&#34;&#34;
    table = self.getTable()
    for x in range(self.size):
        for y in range(self.size):
            if table[x][y] != table[y][x]:
                return (x, y)
    return None</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.performMonotonicityTest"><code class="name flex">
<span>def <span class="ident">performMonotonicityTest</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether the operaration defined by the level set equivalence is
monotone.</p>
<h2 id="returns">Returns</h2>
<p>2-tuple of int: <code>None</code> if it is monotone, <code>(x, y)</code> if it is not
monotone; the pair <code>(x, y)</code> contains the values on which the
monotonicity test has failed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def performMonotonicityTest(self):
    &#34;&#34;&#34;
    Tests whether the operaration defined by the level set equivalence is
    monotone.

    Returns:
        2-tuple of int: `None` if it is monotone, `(x, y)` if it is not
            monotone; the pair `(x, y)` contains the values on which the
            monotonicity test has failed
    &#34;&#34;&#34;
    table = self.getTable()
    for x in range(0, self.size-1, 1):
        for y in range(0, self.size-1, 1):
            if table[x+1][y] &lt; table[x][y] or table[x][y+1] &lt; table[x][y]:
                return (x, y)
    return None</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.performZeroDoublingExtension"><code class="name flex">
<span>def <span class="ident">performZeroDoublingExtension</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs the zero-doubling extension on this tomonoid.</p>
<ul>
<li>Removes all the pairs from the level set equivalence that are
equivalent with (0, 1) and (1, 0).</li>
<li>Enlarges the size of the tomonoid by one adding a new bottom
element.</li>
<li>Recomputes the values of <code>zero</code>, <code>unit</code>, <code>atom</code>, and <code>coatom</code>.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def performZeroDoublingExtension(self):
    &#34;&#34;&#34;
    Performs the zero-doubling extension on this tomonoid.

      * Removes all the pairs from the level set equivalence that are
        equivalent with (0, 1) and (1, 0).
      * Enlarges the size of the tomonoid by one adding a new bottom
        element.
      * Recomputes the values of `zero`, `unit`, `atom`, and `coatom`.
    &#34;&#34;&#34;
    formerSize = self.size

    self.size += 1
    self.setDesignatedValues()

    numEqClasses = len(self.eqClasses)
    if numEqClasses &gt; formerSize:
        # move the last class behind former zero to the end of the list
        self.eqClasses.append(self.eqClasses[self.zero])
        # add (1,0), (0,1), and (0,0) to the zero class
        self.eqClasses[self.zero] = set([(self.unit, self.zero), (self.zero, self.unit), (self.zero, self.zero)])
    else:
        # add (1,0), (0,1), and (0,0) to the zero class
        self.eqClasses.append(set([(self.unit, self.zero), (self.zero, self.unit), (self.zero, self.zero)]))

    # add pairs of type (x,0) and (0,x) to the zero class
    for i in range(self.coatom, self.zero, 1):
        self.eqClasses[self.zero].add((self.zero,i))
        self.eqClasses[self.zero].add((i,self.zero))

    # atom class (former zero class) is used to determine all the single
    # pair undefined equivalence classes
    if self.size &gt; 2:
        for pair in self.eqClasses[self.atom]:
            if self.isNotOnBorder(pair):
                self.eqClasses.append(set([pair]))

    # setting the atom class to (1,at)~(at,1)
    self.eqClasses[self.atom] = set([(self.unit, self.atom), (self.atom, self.unit)])</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.relateClasses"><code class="name flex">
<span>def <span class="ident">relateClasses</span></span>(<span>self, ind1, ind2)</span>
</code></dt>
<dd>
<div class="desc"><p>Merges two level equivalence classes into one.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ind1</code></strong> :&ensp;<code>int</code></dt>
<dd>index of the first class in <code>eqClasses</code></dd>
<dt><strong><code>ind2</code></strong> :&ensp;<code>int</code></dt>
<dd>index of the second class in <code>eqClasses</code></dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fntom.Error.NotTOMPartition" href="Error.html#fntom.Error.NotTOMPartition">NotTOMPartition</a></code></dt>
<dd>if both the classes contain pairs of
the types (1,x) and (x,1)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def relateClasses(self, ind1, ind2):
    &#34;&#34;&#34;
    Merges two level equivalence classes into one.

    Args:
        ind1 (int): index of the first class in `eqClasses`
        ind2 (int): index of the second class in `eqClasses`

    Raises:
        fntom.Error.NotTOMPartition: if both the classes contain pairs of
            the types (1,x) and (x,1)
    &#34;&#34;&#34;
    if ind1 != ind2:
        if self.isElement(ind2):
            if self.isElement(ind1):
                raise fntom.Error.NotTOMPartition([ind1, ind2], self)
            else:
                self.eqClasses[ind2].update(self.eqClasses[ind1])
                self.eqClasses.remove(self.eqClasses[ind1])
        else:
            self.eqClasses[ind1].update(self.eqClasses[ind2])
            self.eqClasses.remove(self.eqClasses[ind2])</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.relateColumn"><code class="name flex">
<span>def <span class="ident">relateColumn</span></span>(<span>self, x, yFrom, yTo)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes the pairs in a bounded column of the Cayley table level
equivalent.</p>
<p>This involves the pairs in the range from <code>(x, yFrom)</code> to <code>(x, yTo)</code>.</p>
<p>The value of <code>yFrom</code> does not need to be lower than <code>yTo</code> (or vice
versa).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>an element of the monoid</dd>
<dt><strong><code>yFrom</code></strong> :&ensp;<code>int</code></dt>
<dd>an element of the monoid</dd>
<dt><strong><code>yTo</code></strong> :&ensp;<code>int</code></dt>
<dd>an element of the monoid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def relateColumn(self, x, yFrom, yTo):
    &#34;&#34;&#34;
    Makes the pairs in a bounded column of the Cayley table level
    equivalent.

    This involves the pairs in the range from `(x, yFrom)` to `(x, yTo)`.

    The value of `yFrom` does not need to be lower than `yTo` (or vice
    versa).

    Args:
        x (int): an element of the monoid
        yFrom (int): an element of the monoid
        yTo (int): an element of the monoid
    &#34;&#34;&#34;
    if yFrom == yTo:
        return
    elif yFrom &lt; yTo:
        rang = range(yFrom, yTo+1, 1)
    elif yFrom &gt; yTo:
        rang = range(yTo, yFrom+1, 1)
    first = None
    for y in rang:
        if first == None:
            first = (x,y)
        else:
            self.relatePairs(first, (x,y))</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.relatePairs"><code class="name flex">
<span>def <span class="ident">relatePairs</span></span>(<span>self, pair1, pair2)</span>
</code></dt>
<dd>
<div class="desc"><p>Merges the level equivalence classes that contain the given pairs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pair1</code></strong> :&ensp;<code>2-tuple</code> of <code>int</code></dt>
<dd>first pair</dd>
<dt><strong><code>pair2</code></strong> :&ensp;<code>2-tuple</code> of <code>int</code></dt>
<dd>second pair</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="fntom.Error.NotTOMPartition" href="Error.html#fntom.Error.NotTOMPartition">NotTOMPartition</a></code></dt>
<dd>if both the classes contain pairs of
the types (1,x) and (x,1)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def relatePairs(self, pair1, pair2):
    &#34;&#34;&#34;
    Merges the level equivalence classes that contain the given pairs.

    Args:
        pair1 (2-tuple of int): first pair
        pair2 (2-tuple of int): second pair

    Raises:
        fntom.Error.NotTOMPartition: if both the classes contain pairs of
            the types (1,x) and (x,1)
    &#34;&#34;&#34;
    if pair1 != pair2:
        (cla1, ind1) = self.findEqClass(pair1)
        (cla2, ind2) = self.findEqClass(pair2)
        self.relateClasses(ind1, ind2)</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.relateRow"><code class="name flex">
<span>def <span class="ident">relateRow</span></span>(<span>self, xFrom, xTo, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes the pairs in a bounded row of the Cayley table level equivalent.</p>
<p>This involves the pairs in the range from <code>(xFrom, y)</code> to <code>(xTo, y)</code>.</p>
<p>The value of <code>xFrom</code> does not need to be lower than <code>xTo</code> (or vice
versa).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xFrom</code></strong> :&ensp;<code>int</code></dt>
<dd>an element of the monoid</dd>
<dt><strong><code>xTo</code></strong> :&ensp;<code>int</code></dt>
<dd>an element of the monoid</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>an element of the monoid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def relateRow(self, xFrom, xTo, y):
    &#34;&#34;&#34;
    Makes the pairs in a bounded row of the Cayley table level equivalent.

    This involves the pairs in the range from `(xFrom, y)` to `(xTo, y)`.

    The value of `xFrom` does not need to be lower than `xTo` (or vice
    versa).

    Args:
        xFrom (int): an element of the monoid
        xTo (int): an element of the monoid
        y (int): an element of the monoid
    &#34;&#34;&#34;
    if xFrom == xTo:
        return
    elif xFrom &lt; xTo:
        ran = range(xFrom, xTo+1, 1)
    elif xFrom &gt; xTo:
        ran = range(xTo, xFrom+1, 1)
    first = None
    for x in ran:
        if first == None:
            first = (x,y)
        else:
            self.relatePairs(first, (x,y))</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.setDesignatedValues"><code class="name flex">
<span>def <span class="ident">setDesignatedValues</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>According to the value of the attribute <code>size</code>, sets the values of
<code>zero</code>, <code>unit</code>, <code>atom</code>, and <code>coatom</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setDesignatedValues(self):
    &#34;&#34;&#34;
    According to the value of the attribute `size`, sets the values of
    `zero`, `unit`, `atom`, and `coatom`.
    &#34;&#34;&#34;
    if self.size == 1:
        self.zero = self.unit = self.atom = self.coatom = 0
    else:
        self.zero = self.size - 1
        self.unit = 0
        self.atom = self.size - 2
        self.coatom = 1</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.setPairToAtom"><code class="name flex">
<span>def <span class="ident">setPairToAtom</span></span>(<span>self, pair)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the given pair to the atom equivalence class.</p>
<p>Merges the class that contains the pair with the class that contains
(1,atom) and (atom,1).
Furthermore, the monotonicity of the tomonoid is taken into account,
i.e., all the pairs that are closer to (1,1) are added to the atom
equivalence class, as well.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pair</code></strong> :&ensp;<code>2-tuple</code> of <code>int</code></dt>
<dd>the pair that is to be evaluated to atom by
the monoidal operation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setPairToAtom(self, pair):
    &#34;&#34;&#34;
    Adds the given pair to the atom equivalence class.

    Merges the class that contains the pair with the class that contains
    (1,atom) and (atom,1).
    Furthermore, the monotonicity of the tomonoid is taken into account,
    i.e., all the pairs that are closer to (1,1) are added to the atom
    equivalence class, as well.

    Args:
        pair (2-tuple of int): the pair that is to be evaluated to atom by
            the monoidal operation
    &#34;&#34;&#34;
    if self.isNotOnBorder(pair):
        for i in range(pair[0], self.unit, -1):
            for j in range(pair[1], self.unit, -1):
                (cla, ind) = self.findEqClass(pair)
                self.mergeEqClassWithAtom(ind)</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.setPairToZero"><code class="name flex">
<span>def <span class="ident">setPairToZero</span></span>(<span>self, pair)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the given pair to the zero equivalence class.</p>
<p>Merges the class that contains the pair with the class that contains
(1,0) and (0,1).
Furthermore, the monotonicity of the tomonoid is taken into account,
i.e., all the pairs that are closer to (0,0) are added to the zero
equivalence class, as well.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pair</code></strong> :&ensp;<code>2-tuple</code> of <code>int</code></dt>
<dd>the pair that is to be evaluated to zero by
the monoidal operation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setPairToZero(self, pair):
    &#34;&#34;&#34;
    Adds the given pair to the zero equivalence class.

    Merges the class that contains the pair with the class that contains
    (1,0) and (0,1).
    Furthermore, the monotonicity of the tomonoid is taken into account,
    i.e., all the pairs that are closer to (0,0) are added to the zero
    equivalence class, as well.

    Args:
        pair (2-tuple of int): the pair that is to be evaluated to zero by
            the monoidal operation
    &#34;&#34;&#34;
    if self.isNotOnBorder(pair):
        for i in range(pair[0], self.zero, 1):
            for j in range(pair[1], self.zero, 1):
                (cla, ind) = self.findEqClass(pair)
                self.mergeEqClassWithZero(ind)</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.setRestToZero"><code class="name flex">
<span>def <span class="ident">setRestToZero</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets all the undetermined pairs to zero.</p>
<p>Undetermined pairs are those that are contained in the equivalence
classes with their indices out of the range of the tomonoid values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setRestToZero(self):
    &#34;&#34;&#34;
    Sets all the undetermined pairs to zero.

    Undetermined pairs are those that are contained in the equivalence
    classes with their indices out of the range of the tomonoid values.
    &#34;&#34;&#34;
    numClasses = len(self.eqClasses)
    for ind in range(numClasses - 1, self.size - 1, -1):
        self.relateClasses(ind, self.zero)</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.setValue"><code class="name flex">
<span>def <span class="ident">setValue</span></span>(<span>self, pair, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the value to which the given pair is supposed to be evaluated
by the monoidal operation.</p>
<p>It, actually, merges (relates) the class that contains <code>pair</code> with the
class that contains the pairs <code>(1,value)</code> and <code>(value,1)</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pair</code></strong> :&ensp;<code>2-tuple</code> of <code>int</code></dt>
<dd>the pair</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>to which value is the pair supposed to be evaluated
(the index of the class)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setValue(self, pair, value):
    &#34;&#34;&#34;
    Defines the value to which the given pair is supposed to be evaluated
    by the monoidal operation.

    It, actually, merges (relates) the class that contains `pair` with the
    class that contains the pairs `(1,value)` and `(value,1)`.

    Args:
        pair (2-tuple of int): the pair
        value (int): to which value is the pair supposed to be evaluated
            (the index of the class)
    &#34;&#34;&#34;
    (cla, ind) = self.findEqClass(pair)
    if ind != value:
        if self.isElement(ind):
            raise fntom.Error.NotTOMPartition([ind, value], self)
        else:
            self.eqClasses[value].update(cla)
            self.eqClasses.remove(cla)</code></pre>
</details>
</dd>
<dt id="fntom.LevelEquivalence.LevelEquivalence.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the values of the attributes of this instance to the terminal
output.</p>
<p>Mostly for debugging purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self):
    &#34;&#34;&#34;
    Prints the values of the attributes of this instance to the terminal
        output.

    Mostly for debugging purposes.
    &#34;&#34;&#34;
    print(self.exportTableToText())
    print(self.exportClassesToText())</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fntom" href="index.html">fntom</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fntom.LevelEquivalence.LevelEquivalence" href="#fntom.LevelEquivalence.LevelEquivalence">LevelEquivalence</a></code></h4>
<ul class="">
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.exportClassesToText" href="#fntom.LevelEquivalence.LevelEquivalence.exportClassesToText">exportClassesToText</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.exportTableToText" href="#fntom.LevelEquivalence.LevelEquivalence.exportTableToText">exportTableToText</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.findEqClass" href="#fntom.LevelEquivalence.LevelEquivalence.findEqClass">findEqClass</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.findIdempotents" href="#fntom.LevelEquivalence.LevelEquivalence.findIdempotents">findIdempotents</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.getCopy" href="#fntom.LevelEquivalence.LevelEquivalence.getCopy">getCopy</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.getTable" href="#fntom.LevelEquivalence.LevelEquivalence.getTable">getTable</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.getValue" href="#fntom.LevelEquivalence.LevelEquivalence.getValue">getValue</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.isAtomOrHigher" href="#fntom.LevelEquivalence.LevelEquivalence.isAtomOrHigher">isAtomOrHigher</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.isAtomOrNotElement" href="#fntom.LevelEquivalence.LevelEquivalence.isAtomOrNotElement">isAtomOrNotElement</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.isElement" href="#fntom.LevelEquivalence.LevelEquivalence.isElement">isElement</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.isHigherThanAtom" href="#fntom.LevelEquivalence.LevelEquivalence.isHigherThanAtom">isHigherThanAtom</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.isNotOnBorder" href="#fntom.LevelEquivalence.LevelEquivalence.isNotOnBorder">isNotOnBorder</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.isZeroOrAtomOrNotElement" href="#fntom.LevelEquivalence.LevelEquivalence.isZeroOrAtomOrNotElement">isZeroOrAtomOrNotElement</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.mergeEqClassWithAtom" href="#fntom.LevelEquivalence.LevelEquivalence.mergeEqClassWithAtom">mergeEqClassWithAtom</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.mergeEqClassWithZero" href="#fntom.LevelEquivalence.LevelEquivalence.mergeEqClassWithZero">mergeEqClassWithZero</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.performArchimedeanicityTest" href="#fntom.LevelEquivalence.LevelEquivalence.performArchimedeanicityTest">performArchimedeanicityTest</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.performAssociativityTest" href="#fntom.LevelEquivalence.LevelEquivalence.performAssociativityTest">performAssociativityTest</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.performCommutativityTest" href="#fntom.LevelEquivalence.LevelEquivalence.performCommutativityTest">performCommutativityTest</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.performMonotonicityTest" href="#fntom.LevelEquivalence.LevelEquivalence.performMonotonicityTest">performMonotonicityTest</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.performZeroDoublingExtension" href="#fntom.LevelEquivalence.LevelEquivalence.performZeroDoublingExtension">performZeroDoublingExtension</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.relateClasses" href="#fntom.LevelEquivalence.LevelEquivalence.relateClasses">relateClasses</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.relateColumn" href="#fntom.LevelEquivalence.LevelEquivalence.relateColumn">relateColumn</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.relatePairs" href="#fntom.LevelEquivalence.LevelEquivalence.relatePairs">relatePairs</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.relateRow" href="#fntom.LevelEquivalence.LevelEquivalence.relateRow">relateRow</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.setDesignatedValues" href="#fntom.LevelEquivalence.LevelEquivalence.setDesignatedValues">setDesignatedValues</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.setPairToAtom" href="#fntom.LevelEquivalence.LevelEquivalence.setPairToAtom">setPairToAtom</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.setPairToZero" href="#fntom.LevelEquivalence.LevelEquivalence.setPairToZero">setPairToZero</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.setRestToZero" href="#fntom.LevelEquivalence.LevelEquivalence.setRestToZero">setRestToZero</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.setValue" href="#fntom.LevelEquivalence.LevelEquivalence.setValue">setValue</a></code></li>
<li><code><a title="fntom.LevelEquivalence.LevelEquivalence.show" href="#fntom.LevelEquivalence.LevelEquivalence.show">show</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>