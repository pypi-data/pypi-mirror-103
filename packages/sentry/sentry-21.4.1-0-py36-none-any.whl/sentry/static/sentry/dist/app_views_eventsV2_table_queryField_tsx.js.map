{"version":3,"sources":["webpack:///./app/views/eventsV2/table/queryField.tsx"],"names":["QueryField","selected","value","current","props","fieldValue","cloneDeep","kind","FieldValueKind","field","meta","name","function","undefined","Error","parameters","forEach","param","i","getFieldOrTagOrMeasurementValue","defaultValue","validateColumnTypes","columnTypes","length","triggerChange","newColumn","this","onChange","fieldOptions","fieldName","measurementName","spanOperationBreakdownName","tagName","indexOf","replace","dataType","unknown","funcName","appendFieldIfUnknown","parameterDescriptions","map","index","fieldParameter","required","options","Object","values","filter","assign","label","disabled","inFieldLabels","filterAggregateParameters","inputs","descriptor","aggregateParameters","key","placeholder","t","handleFieldParameterChange","inFieldLabel","handler","handleScalarParameterChange","handleRefinementChange","inputProps","onUpdate","BufferedInput","type","inputMode","pattern","gridColumns","requiredInputs","push","BlankSpace","text","tagType","shouldRenderTag","className","takeFocus","filterPrimaryOptions","getFieldData","allFieldOptions","selectProps","handleFieldChange","autoFocus","styles","singleValue","provided","display","justifyContent","alignItems","width","option","renderParameterInputs","Container","components","Option","data","data-test-id","renderTag","SingleValue","React","input","includes","p","space","isValid","state","setState","event","target","validity","valid","StyledInput","ref","handleChange","onBlur","handleBlur","Input","theme","backgroundSecondary","borderRadius","fontSizeMedium","gray300"],"mappings":"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","file":"app_views_eventsV2_table_queryField_tsx.e0987fd2ef6df3a5a85c.js","sourcesContent":["import React, {CSSProperties} from 'react';\nimport {components, OptionProps, SingleValueProps} from 'react-select';\nimport styled from '@emotion/styled';\nimport cloneDeep from 'lodash/cloneDeep';\n\nimport SelectControl, {ControlProps} from 'app/components/forms/selectControl';\nimport Tag from 'app/components/tag';\nimport {t} from 'app/locale';\nimport space from 'app/styles/space';\nimport {SelectValue} from 'app/types';\nimport {\n  AggregateParameter,\n  AggregationKey,\n  ColumnType,\n  QueryFieldValue,\n  ValidateColumnTypes,\n} from 'app/utils/discover/fields';\nimport Input from 'app/views/settings/components/forms/controls/input';\n\nimport {FieldValue, FieldValueColumns, FieldValueKind} from './types';\n\ntype FieldValueOption = SelectValue<FieldValue>;\n\ntype FieldOptions = Record<string, FieldValueOption>;\n\n// Intermediate type that combines the current column\n// data with the AggregateParameter type.\ntype ParameterDescription =\n  | {\n      kind: 'value';\n      value: string;\n      dataType: ColumnType;\n      required: boolean;\n    }\n  | {\n      kind: 'column';\n      value: FieldValue | null;\n      options: FieldValueOption[];\n      required: boolean;\n    };\n\ntype Props = {\n  className?: string;\n  takeFocus?: boolean;\n  fieldValue: QueryFieldValue;\n  fieldOptions: FieldOptions;\n  /**\n   * The number of columns to render. Columns that do not have a parameter will\n   * render an empty parameter placeholder. Leave blank to avoid adding spacers.\n   */\n  gridColumns?: number;\n  /**\n   * Filter the options in the primary selector. Useful if you only want to\n   * show a subset of selectable items.\n   *\n   * NOTE: This is different from passing an already filtered fieldOptions\n   * list, as tag items in the list may be used as parameters to functions.\n   */\n  filterPrimaryOptions?: (option: FieldValueOption) => boolean;\n  /**\n   * Function to filter the options that are used as parameters for function/aggregate.\n   */\n  filterAggregateParameters?: (option: FieldValueOption) => boolean;\n  /**\n   * Whether or not to add labels inside of the input fields, currently only\n   * used for the metric alert builder.\n   */\n  inFieldLabels?: boolean;\n  /**\n   * Whether or not to add the tag explaining the FieldValueKind of each field\n   */\n  shouldRenderTag?: boolean;\n  onChange: (fieldValue: QueryFieldValue) => void;\n  disabled?: boolean;\n};\n\n// Type for completing generics in react-select\ntype OptionType = {\n  label: string;\n  value: FieldValue;\n};\n\nclass QueryField extends React.Component<Props> {\n  handleFieldChange = (selected?: FieldValueOption | null) => {\n    if (!selected) {\n      return;\n    }\n    const {value} = selected;\n    const current = this.props.fieldValue;\n    let fieldValue: QueryFieldValue = cloneDeep(this.props.fieldValue);\n\n    switch (value.kind) {\n      case FieldValueKind.TAG:\n      case FieldValueKind.MEASUREMENT:\n      case FieldValueKind.BREAKDOWN:\n      case FieldValueKind.FIELD:\n        fieldValue = {kind: 'field', field: value.meta.name};\n        break;\n      case FieldValueKind.FUNCTION:\n        if (current.kind === 'field') {\n          fieldValue = {\n            kind: 'function',\n            function: [value.meta.name as AggregationKey, '', undefined],\n          };\n        } else if (current.kind === 'function') {\n          fieldValue = {\n            kind: 'function',\n            function: [\n              value.meta.name as AggregationKey,\n              current.function[1],\n              current.function[2],\n            ],\n          };\n        }\n        break;\n      default:\n        throw new Error('Invalid field type found in column picker');\n    }\n\n    if (value.kind === FieldValueKind.FUNCTION) {\n      value.meta.parameters.forEach((param: AggregateParameter, i: number) => {\n        if (fieldValue.kind !== 'function') {\n          return;\n        }\n        if (param.kind === 'column') {\n          const field = this.getFieldOrTagOrMeasurementValue(fieldValue.function[i + 1]);\n          if (field === null) {\n            fieldValue.function[i + 1] = param.defaultValue || '';\n          } else if (\n            (field.kind === FieldValueKind.FIELD ||\n              field.kind === FieldValueKind.TAG ||\n              field.kind === FieldValueKind.MEASUREMENT ||\n              field.kind === FieldValueKind.BREAKDOWN) &&\n            validateColumnTypes(param.columnTypes as ValidateColumnTypes, field)\n          ) {\n            // New function accepts current field.\n            fieldValue.function[i + 1] = field.meta.name;\n          } else {\n            // field does not fit within new function requirements, use the default.\n            fieldValue.function[i + 1] = param.defaultValue || '';\n            fieldValue.function[i + 2] = undefined;\n          }\n        } else if (param.kind === 'value') {\n          fieldValue.function[i + 1] = param.defaultValue || '';\n        }\n      });\n\n      if (fieldValue.kind === 'function') {\n        if (value.meta.parameters.length === 0) {\n          fieldValue.function = [fieldValue.function[0], '', undefined];\n        } else if (value.meta.parameters.length === 1) {\n          fieldValue.function[2] = undefined;\n        }\n      }\n    }\n\n    this.triggerChange(fieldValue);\n  };\n\n  handleFieldParameterChange = ({value}) => {\n    const newColumn = cloneDeep(this.props.fieldValue);\n    if (newColumn.kind === 'function') {\n      newColumn.function[1] = value.meta.name;\n    }\n    this.triggerChange(newColumn);\n  };\n\n  handleScalarParameterChange = (value: string) => {\n    const newColumn = cloneDeep(this.props.fieldValue);\n    if (newColumn.kind === 'function') {\n      newColumn.function[1] = value;\n    }\n    this.triggerChange(newColumn);\n  };\n\n  handleRefinementChange = (value: string) => {\n    const newColumn = cloneDeep(this.props.fieldValue);\n    if (newColumn.kind === 'function') {\n      newColumn.function[2] = value;\n    }\n    this.triggerChange(newColumn);\n  };\n\n  triggerChange(fieldValue: QueryFieldValue) {\n    this.props.onChange(fieldValue);\n  }\n\n  getFieldOrTagOrMeasurementValue(name: string | undefined): FieldValue | null {\n    const {fieldOptions} = this.props;\n    if (name === undefined) {\n      return null;\n    }\n\n    const fieldName = `field:${name}`;\n    if (fieldOptions[fieldName]) {\n      return fieldOptions[fieldName].value;\n    }\n\n    const measurementName = `measurement:${name}`;\n    if (fieldOptions[measurementName]) {\n      return fieldOptions[measurementName].value;\n    }\n\n    const spanOperationBreakdownName = `span_op_breakdown:${name}`;\n    if (fieldOptions[spanOperationBreakdownName]) {\n      return fieldOptions[spanOperationBreakdownName].value;\n    }\n\n    const tagName =\n      name.indexOf('tags[') === 0\n        ? `tag:${name.replace(/tags\\[(.*?)\\]/, '$1')}`\n        : `tag:${name}`;\n\n    if (fieldOptions[tagName]) {\n      return fieldOptions[tagName].value;\n    }\n\n    // Likely a tag that was deleted but left behind in a saved query\n    // Cook up a tag option so select control works.\n    if (name.length > 0) {\n      return {\n        kind: FieldValueKind.TAG,\n        meta: {\n          name,\n          dataType: 'string',\n          unknown: true,\n        },\n      };\n    }\n    return null;\n  }\n\n  getFieldData() {\n    let field: FieldValue | null = null;\n\n    const {fieldValue} = this.props;\n    let {fieldOptions} = this.props;\n\n    if (fieldValue.kind === 'function') {\n      const funcName = `function:${fieldValue.function[0]}`;\n      if (fieldOptions[funcName] !== undefined) {\n        field = fieldOptions[funcName].value;\n      }\n    }\n\n    if (fieldValue.kind === 'field') {\n      field = this.getFieldOrTagOrMeasurementValue(fieldValue.field);\n      fieldOptions = this.appendFieldIfUnknown(fieldOptions, field);\n    }\n\n    let parameterDescriptions: ParameterDescription[] = [];\n    // Generate options and values for each parameter.\n    if (\n      field &&\n      field.kind === FieldValueKind.FUNCTION &&\n      field.meta.parameters.length > 0 &&\n      fieldValue.kind === FieldValueKind.FUNCTION\n    ) {\n      parameterDescriptions = field.meta.parameters.map(\n        (param, index: number): ParameterDescription => {\n          if (param.kind === 'column') {\n            const fieldParameter = this.getFieldOrTagOrMeasurementValue(\n              fieldValue.function[1]\n            );\n            fieldOptions = this.appendFieldIfUnknown(fieldOptions, fieldParameter);\n            return {\n              kind: 'column',\n              value: fieldParameter,\n              required: param.required,\n              options: Object.values(fieldOptions).filter(\n                ({value}) =>\n                  (value.kind === FieldValueKind.FIELD ||\n                    value.kind === FieldValueKind.TAG ||\n                    value.kind === FieldValueKind.MEASUREMENT ||\n                    value.kind === FieldValueKind.BREAKDOWN) &&\n                  validateColumnTypes(param.columnTypes as ValidateColumnTypes, value)\n              ),\n            };\n          }\n\n          return {\n            kind: 'value',\n            value:\n              (fieldValue.kind === 'function' && fieldValue.function[index + 1]) ||\n              param.defaultValue ||\n              '',\n            dataType: param.dataType,\n            required: param.required,\n          };\n        }\n      );\n    }\n    return {field, fieldOptions, parameterDescriptions};\n  }\n\n  appendFieldIfUnknown(\n    fieldOptions: FieldOptions,\n    field: FieldValue | null\n  ): FieldOptions {\n    if (!field) {\n      return fieldOptions;\n    }\n\n    if (field && field.kind === FieldValueKind.TAG && field.meta.unknown) {\n      // Clone the options so we don't mutate other rows.\n      fieldOptions = Object.assign({}, fieldOptions);\n      fieldOptions[field.meta.name] = {label: field.meta.name, value: field};\n    }\n\n    return fieldOptions;\n  }\n\n  renderParameterInputs(parameters: ParameterDescription[]): React.ReactNode[] {\n    const {disabled, inFieldLabels, filterAggregateParameters} = this.props;\n    const inputs = parameters.map((descriptor: ParameterDescription, index: number) => {\n      if (descriptor.kind === 'column' && descriptor.options.length > 0) {\n        const aggregateParameters = filterAggregateParameters\n          ? descriptor.options.filter(filterAggregateParameters)\n          : descriptor.options;\n\n        return (\n          <SelectControl\n            key=\"select\"\n            name=\"parameter\"\n            placeholder={t('Select value')}\n            options={aggregateParameters}\n            value={descriptor.value}\n            required={descriptor.required}\n            onChange={this.handleFieldParameterChange}\n            inFieldLabel={inFieldLabels ? t('Parameter: ') : undefined}\n            disabled={disabled}\n          />\n        );\n      }\n      if (descriptor.kind === 'value') {\n        const handler =\n          index === 0 ? this.handleScalarParameterChange : this.handleRefinementChange;\n\n        const inputProps = {\n          required: descriptor.required,\n          value: descriptor.value,\n          onUpdate: handler,\n          disabled,\n        };\n        switch (descriptor.dataType) {\n          case 'number':\n            return (\n              <BufferedInput\n                name=\"refinement\"\n                key=\"parameter:number\"\n                type=\"text\"\n                inputMode=\"numeric\"\n                pattern=\"[0-9]*(\\.[0-9]*)?\"\n                {...inputProps}\n              />\n            );\n          case 'integer':\n            return (\n              <BufferedInput\n                name=\"refinement\"\n                key=\"parameter:integer\"\n                type=\"text\"\n                inputMode=\"numeric\"\n                pattern=\"[0-9]*\"\n                {...inputProps}\n              />\n            );\n          default:\n            return (\n              <BufferedInput\n                name=\"refinement\"\n                key=\"parameter:text\"\n                type=\"text\"\n                {...inputProps}\n              />\n            );\n        }\n      }\n      throw new Error(`Unknown parameter type encountered for ${this.props.fieldValue}`);\n    });\n\n    // Add enough disabled inputs to fill the grid up.\n    // We always have 1 input.\n    const {gridColumns} = this.props;\n    const requiredInputs = (gridColumns ?? inputs.length + 1) - inputs.length - 1;\n    if (gridColumns !== undefined && requiredInputs > 0) {\n      for (let i = 0; i < requiredInputs; i++) {\n        inputs.push(<BlankSpace key={i} />);\n      }\n    }\n\n    return inputs;\n  }\n\n  renderTag(kind) {\n    const {shouldRenderTag} = this.props;\n    if (shouldRenderTag === false) {\n      return null;\n    }\n    let text, tagType;\n    switch (kind) {\n      case FieldValueKind.FUNCTION:\n        text = 'f(x)';\n        tagType = 'success';\n        break;\n      case FieldValueKind.MEASUREMENT:\n        text = 'measure';\n        tagType = 'info';\n        break;\n      case FieldValueKind.BREAKDOWN:\n        text = 'breakdown';\n        tagType = 'error';\n        break;\n      case FieldValueKind.TAG:\n        text = kind;\n        tagType = 'warning';\n        break;\n      case FieldValueKind.FIELD:\n        text = kind;\n        tagType = 'highlight';\n        break;\n      default:\n        text = kind;\n    }\n    return <Tag type={tagType}>{text}</Tag>;\n  }\n\n  render() {\n    const {\n      className,\n      takeFocus,\n      filterPrimaryOptions,\n      inFieldLabels,\n      disabled,\n    } = this.props;\n    const {field, fieldOptions, parameterDescriptions} = this.getFieldData();\n\n    const allFieldOptions = filterPrimaryOptions\n      ? Object.values(fieldOptions).filter(filterPrimaryOptions)\n      : Object.values(fieldOptions);\n\n    const selectProps: ControlProps<FieldValueOption> = {\n      name: 'field',\n      options: Object.values(allFieldOptions),\n      placeholder: t('(Required)'),\n      value: field,\n      onChange: this.handleFieldChange,\n      inFieldLabel: inFieldLabels ? t('Function: ') : undefined,\n      disabled,\n    };\n    if (takeFocus && field === null) {\n      selectProps.autoFocus = true;\n    }\n\n    const styles = {\n      singleValue(provided: CSSProperties) {\n        const custom = {\n          display: 'flex',\n          justifyContent: 'space-between',\n          alignItems: 'center',\n          width: 'calc(100% - 10px)',\n        };\n        return {...provided, ...custom};\n      },\n      option(provided: CSSProperties) {\n        const custom = {\n          display: 'flex',\n          justifyContent: 'space-between',\n          alignItems: 'center',\n          width: '100%',\n        };\n        return {...provided, ...custom};\n      },\n    };\n\n    const parameters = this.renderParameterInputs(parameterDescriptions);\n\n    return (\n      <Container className={className} gridColumns={parameters.length + 1}>\n        <SelectControl\n          {...selectProps}\n          styles={!inFieldLabels ? styles : undefined}\n          components={{\n            Option: ({label, data, ...props}: OptionProps<OptionType>) => (\n              <components.Option label={label} data={data} {...props}>\n                <span data-test-id=\"label\">{label}</span>\n                {this.renderTag(data.value.kind)}\n              </components.Option>\n            ),\n            SingleValue: ({data, ...props}: SingleValueProps<OptionType>) => (\n              <components.SingleValue data={data} {...props}>\n                <span data-test-id=\"label\">{data.label}</span>\n                {this.renderTag(data.value.kind)}\n              </components.SingleValue>\n            ),\n          }}\n        />\n        {parameters}\n      </Container>\n    );\n  }\n}\n\nfunction validateColumnTypes(\n  columnTypes: ValidateColumnTypes,\n  input: FieldValueColumns\n): boolean {\n  if (typeof columnTypes === 'function') {\n    return columnTypes({name: input.meta.name, dataType: input.meta.dataType});\n  }\n\n  return columnTypes.includes(input.meta.dataType);\n}\n\nconst Container = styled('div')<{gridColumns: number}>`\n  display: grid;\n  grid-template-columns: repeat(${p => p.gridColumns}, 1fr);\n  grid-column-gap: ${space(1)};\n  align-items: center;\n\n  flex-grow: 1;\n`;\n\ntype InputProps = React.HTMLProps<HTMLInputElement> & {\n  onUpdate: (value: string) => void;\n  value: string;\n};\ntype InputState = {value: string};\n\n/**\n * Because controlled inputs fire onChange on every key stroke,\n * we can't update the QueryField that often as it would re-render\n * the input elements causing focus to be lost.\n *\n * Using a buffered input lets us throttle rendering and enforce data\n * constraints better.\n */\nclass BufferedInput extends React.Component<InputProps, InputState> {\n  constructor(props: InputProps) {\n    super(props);\n    this.input = React.createRef();\n  }\n\n  state = {\n    value: this.props.value,\n  };\n\n  private input: React.RefObject<HTMLInputElement>;\n\n  get isValid() {\n    if (!this.input.current) {\n      return true;\n    }\n    return this.input.current.validity.valid;\n  }\n\n  handleBlur = () => {\n    if (this.isValid) {\n      this.props.onUpdate(this.state.value);\n    } else {\n      this.setState({value: this.props.value});\n    }\n  };\n\n  handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    if (this.isValid) {\n      this.setState({value: event.target.value});\n    }\n  };\n\n  render() {\n    const {onUpdate: _, ...props} = this.props;\n    return (\n      <StyledInput\n        {...props}\n        ref={this.input}\n        className=\"form-control\"\n        value={this.state.value}\n        onChange={this.handleChange}\n        onBlur={this.handleBlur}\n      />\n    );\n  }\n}\n\n// Set a min-width to allow shrinkage in grid.\nconst StyledInput = styled(Input)`\n  /* Match the height of the select boxes */\n  height: 41px;\n  min-width: 50px;\n`;\n\nconst BlankSpace = styled('div')`\n  /* Match the height of the select boxes */\n  height: 41px;\n  min-width: 50px;\n  background: ${p => p.theme.backgroundSecondary};\n  border-radius: ${p => p.theme.borderRadius};\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  &:after {\n    font-size: ${p => p.theme.fontSizeMedium};\n    content: '${t('No parameter')}';\n    color: ${p => p.theme.gray300};\n  }\n`;\n\nexport {QueryField};\n"],"sourceRoot":""}