{"version":3,"sources":["webpack:///./app/components/internalStatChart.tsx","webpack:///./app/views/admin/adminBuffer.tsx"],"names":["InternalStatChart","error","loading","data","setState","props","api","request","method","since","resolution","key","stat","success","this","fetchData","_nextProps","nextState","state","prevProps","label","height","onRetry","series","seriesName","map","name","value","isGroupedByDate","showTimeInTooltip","labelYAxisExtents","React","withApi","AdminBuffer","Date","getTime","className"],"mappings":"28BAuBMA,E,wnBACW,CACbC,OAAO,EACPC,SAAS,EACTC,KAAM,Q,+BAqBI,WACV,EAAKC,SAAS,CAACF,SAAS,IACxB,EAAKG,MAAMC,IAAIC,QAAQ,mBAAoB,CACzCC,OAAQ,MACRL,KAAM,CACJM,MAAO,EAAKJ,MAAMI,MAClBC,WAAY,EAAKL,MAAMK,WACvBC,IAAK,EAAKN,MAAMO,MAElBC,QAAS,SAAAV,GAAI,OACX,EAAKC,SAAS,CACZD,OACAD,SAAS,EACTD,OAAO,KAEXA,MAAO,kBAAM,EAAKG,SAAS,CAACH,OAAO,EAAMC,SAAS,U,kDAjCtD,WACEY,KAAKC,c,mCAGP,SAAsBC,EAAmBC,GACvC,OAAOH,KAAKI,MAAMhB,UAAYe,EAAUf,U,gCAG1C,SAAmBiB,GAEfA,EAAUV,QAAUK,KAAKT,MAAMI,OAC/BU,EAAUP,OAASE,KAAKT,MAAMO,MAC9BO,EAAUT,aAAeI,KAAKT,MAAMK,YAEpCI,KAAKC,c,oBAuBT,WAAS,QACwBD,KAAKI,MAA7BhB,EADA,EACAA,QAASD,EADT,EACSA,MAAOE,EADhB,EACgBA,KADhB,EAEiBW,KAAKT,MAAtBe,EAFA,EAEAA,MAAOC,EAFP,EAEOA,OACd,GAAInB,EACF,OAAO,QAAC,IAAD,MACF,GAAID,EACT,OAAO,QAAC,IAAD,CAAcqB,QAASR,KAAKC,YAGrC,IAAMQ,EAAS,CACbC,WAAYJ,EACZjB,KAAI,UACFA,aADE,EACFA,EAAMsB,KAAI,qCAAyB,CACjCC,KAAkB,IADV,KAERC,MAFQ,gBADR,QAIK,IAEX,OACE,QAAC,IAAD,CACEN,OAAQA,UAAU,IAClBE,OAAQ,CAACA,GACTK,iBAAe,EACfC,mBAAiB,EACjBC,mBAAiB,Q,GAnEOC,aAA1B/B,E,gCAyEN,SAAegC,OAAQhC,I,6OC5FjBiC,EAAc,WAClB,IAAMxB,GAAQ,IAAIyB,MAAOC,UAAY,IAAO,OAE5C,OACE,oBACE,8BAEA,eAAKC,UAAU,QACb,eAAKA,UAAU,eACb,6BAGF,eAAKA,UAAU,6BACb,mKAEsE,KACpE,+BAHF,mGASJ,eAAKA,UAAU,QACb,eAAKA,UAAU,eACb,yCAEF,QAAC,IAAD,CACE3B,MAAOA,EACPC,WAAW,KACXE,KAAK,yDACLQ,MAAM,WAIV,eAAKgB,UAAU,QACb,eAAKA,UAAU,eACb,uCAEF,QAAC,IAAD,CACE3B,MAAOA,EACPC,WAAW,KACXE,KAAK,iBACLQ,MAAM,YA1CVa,E,0BAiDN","file":"AdminBuffer.c040dc3c0713f5a1cfa0.js","sourcesContent":["import React from 'react';\n\nimport {Client} from 'app/api';\nimport MiniBarChart from 'app/components/charts/miniBarChart';\nimport LoadingError from 'app/components/loadingError';\nimport LoadingIndicator from 'app/components/loadingIndicator';\nimport withApi from 'app/utils/withApi';\n\ntype Props = {\n  api: Client;\n  since: number;\n  resolution: string;\n  stat: string;\n  label: string;\n  height?: number;\n};\n\ntype State = {\n  error: boolean;\n  loading: boolean;\n  data: [number, number][] | null;\n};\n\nclass InternalStatChart extends React.Component<Props, State> {\n  state: State = {\n    error: false,\n    loading: true,\n    data: null,\n  };\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  shouldComponentUpdate(_nextProps: Props, nextState: State) {\n    return this.state.loading !== nextState.loading;\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (\n      prevProps.since !== this.props.since ||\n      prevProps.stat !== this.props.stat ||\n      prevProps.resolution !== this.props.resolution\n    ) {\n      this.fetchData();\n    }\n  }\n\n  fetchData = () => {\n    this.setState({loading: true});\n    this.props.api.request('/internal/stats/', {\n      method: 'GET',\n      data: {\n        since: this.props.since,\n        resolution: this.props.resolution,\n        key: this.props.stat,\n      },\n      success: data =>\n        this.setState({\n          data,\n          loading: false,\n          error: false,\n        }),\n      error: () => this.setState({error: true, loading: false}),\n    });\n  };\n\n  render() {\n    const {loading, error, data} = this.state;\n    const {label, height} = this.props;\n    if (loading) {\n      return <LoadingIndicator />;\n    } else if (error) {\n      return <LoadingError onRetry={this.fetchData} />;\n    }\n\n    const series = {\n      seriesName: label,\n      data:\n        data?.map(([timestamp, value]) => ({\n          name: timestamp * 1000,\n          value,\n        })) ?? [],\n    };\n    return (\n      <MiniBarChart\n        height={height ?? 150}\n        series={[series]}\n        isGroupedByDate\n        showTimeInTooltip\n        labelYAxisExtents\n      />\n    );\n  }\n}\n\nexport default withApi(InternalStatChart);\n","import React from 'react';\n\nimport InternalStatChart from 'app/components/internalStatChart';\n\nconst AdminBuffer = () => {\n  const since = new Date().getTime() / 1000 - 3600 * 24 * 7;\n\n  return (\n    <div>\n      <h3>Buffers</h3>\n\n      <div className=\"box\">\n        <div className=\"box-header\">\n          <h4>About</h4>\n        </div>\n\n        <div className=\"box-content with-padding\">\n          <p>\n            Sentry buffers are responsible for making changes to cardinality counters —\n            such as an issues event count — as well as updating attributes like{' '}\n            <em>last seen</em>. These are flushed on a regularly interval, and are\n            directly affected by the queue backlog.\n          </p>\n        </div>\n      </div>\n\n      <div className=\"box\">\n        <div className=\"box-header\">\n          <h4>Updates Processed</h4>\n        </div>\n        <InternalStatChart\n          since={since}\n          resolution=\"1h\"\n          stat=\"jobs.finished.sentry.tasks.process_buffer.process_incr\"\n          label=\"Jobs\"\n        />\n      </div>\n\n      <div className=\"box\">\n        <div className=\"box-header\">\n          <h4>Revoked Updates</h4>\n        </div>\n        <InternalStatChart\n          since={since}\n          resolution=\"1h\"\n          stat=\"buffer.revoked\"\n          label=\"Jobs\"\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default AdminBuffer;\n"],"sourceRoot":""}