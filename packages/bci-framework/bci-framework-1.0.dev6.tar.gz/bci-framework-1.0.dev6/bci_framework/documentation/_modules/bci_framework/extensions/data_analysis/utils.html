
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>bci_framework.extensions.data_analysis.utils &#8212; BCI-Framework  documentation</title>
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/custom.css" />
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favico.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for bci_framework.extensions.data_analysis.utils</h1><div class="highlight"><pre>
<span></span>&quot;&quot;&quot;
=====
Utils
=====

This module define usefull decorators to use with data analysis.
&quot;&quot;&quot;

import time
import random
from datetime import datetime, timedelta
from multiprocessing import Process
from threading import Thread
from typing import Callable, Union, List

import numpy as np
from openbci_stream.acquisition import OpenBCIConsumer

from ...extensions import properties as prop


class data:
    value = {
        &#39;context&#39;: {},
    }


# ----------------------------------------------------------------------
<div class="viewcode-block" id="subprocess_this"><a class="viewcode-back" href="../../../bci_framework.extensions.data_analysis.utils.html#bci_framework.extensions.data_analysis.utils.subprocess_this">[docs]</a>def subprocess_this(fn: Callable) -&gt; Callable:
    &quot;&quot;&quot;Decorator to move methods to subprocessing.&quot;&quot;&quot;

    def wraper(*args, **kwargs):
        c = Process(target=fn, args=args)
        c.start()
    return wraper</div>


# ----------------------------------------------------------------------
<div class="viewcode-block" id="thread_this"><a class="viewcode-back" href="../../../bci_framework.extensions.data_analysis.utils.html#bci_framework.extensions.data_analysis.utils.thread_this">[docs]</a>def thread_this(fn: Callable) -&gt; Callable:
    &quot;&quot;&quot;Decorator to move methods to threading.&quot;&quot;&quot;

    def wraper(*args, **kwargs):
        c = Thread(target=fn, args=args)
        c.start()
    return wraper</div>


# ----------------------------------------------------------------------
<div class="viewcode-block" id="timeit"><a class="viewcode-back" href="../../../bci_framework.extensions.data_analysis.utils.html#bci_framework.extensions.data_analysis.utils.timeit">[docs]</a>def timeit(fn: Callable) -&gt; Callable:
    &quot;&quot;&quot;Decorator to calculate the execution time of a method.&quot;&quot;&quot;

    def wraper(self, *args, **kwargs):
        t0 = time.time()
        r = fn(self, *args, **kwargs)
        t1 = time.time()
        print(f&quot;[timeit] {fn.__name__}: {(t1-t0)*1000:.2f} ms&quot;)
        return r
    return wraper</div>


# ----------------------------------------------------------------------
<div class="viewcode-block" id="loop_consumer"><a class="viewcode-back" href="../../../bci_framework.extensions.data_analysis.utils.html#bci_framework.extensions.data_analysis.utils.loop_consumer">[docs]</a>def loop_consumer(*topics) -&gt; Callable:
    &quot;&quot;&quot;Decorator to iterate methods with new streamming data.

    This decorator will call a method on every new data streamming input.
    &quot;&quot;&quot;
    def wrap_wrap(fn: Callable) -&gt; Callable:

        arguments = fn.__code__.co_varnames[1:fn.__code__.co_argcount]

        def wrap(cls):
            with OpenBCIConsumer(host=prop.HOST, topics=topics) as stream:
                frame = 0
                for data in stream:
                    if data.topic == &#39;eeg&#39;:
                        frame += 1
                        if hasattr(cls, &#39;buffer_eeg&#39;):
                            cls.update_buffer(
                                *data.value[&#39;data&#39;], data.value[&#39;context&#39;][&#39;binary_created&#39;])
                        # latency calculated with `binary_created`
                        latency = (datetime.now() - datetime.fromtimestamp(
                            data.value[&#39;context&#39;][&#39;binary_created&#39;])).total_seconds() * 1000
                        data_ = data.value[&#39;data&#39;]
                    else:
                        # latency calculated with kafka timestamp
                        latency = (datetime.now(
                        ) - datetime.fromtimestamp(data.timestamp / 1000)).total_seconds() * 1000

                        data_ = data.value

                    kwargs = {&#39;data&#39;: data_,
                              &#39;kafka_stream&#39;: data,
                              &#39;topic&#39;: data.topic,
                              &#39;frame&#39;: frame,
                              &#39;latency&#39;: latency,
                              }

                    fn(*[cls] + [kwargs[v] for v in arguments])
        return wrap
    return wrap_wrap</div>


# ----------------------------------------------------------------------
<div class="viewcode-block" id="fake_loop_consumer"><a class="viewcode-back" href="../../../bci_framework.extensions.data_analysis.utils.html#bci_framework.extensions.data_analysis.utils.fake_loop_consumer">[docs]</a>def fake_loop_consumer(*topics) -&gt; Callable:
    &quot;&quot;&quot;Decorator to iterate methods with new streamming data.

    This decorator will call a method with fake data.
    &quot;&quot;&quot;

    # ----------------------------------------------------------------------
    def wrap_wrap(fn: Callable) -&gt; Callable:

        arguments = fn.__code__.co_varnames[1:fn.__code__.co_argcount]

        def wrap(cls):
            frame = 0

            while True:
                frame += 1
                t0 = time.time()

                num_data = int(prop.STREAMING_PACKAGE_SIZE)
                num_data = random.randint(num_data - 10, num_data + 10)

                eeg = np.random.normal(0, 0.2, size=(
                    len(prop.CHANNELS), num_data))

                if prop.BOARDMODE == &#39;default&#39;:
                    aux = np.random.normal(0, 0.2, size=(3, num_data))
                elif prop.BOARDMODE == &#39;analog&#39;:
                    if prop.CONNECTION == &#39;wifi&#39;:
                        aux = np.random.normal(0, 0.07, size=(2, num_data))
                    else:
                        aux = np.random.normal(0, 0.07, size=(3, num_data))

                    if (time.time() // 1) % 2:
                        aux += 1

                elif prop.BOARDMODE == &#39;digital&#39;:
                    if prop.CONNECTION == &#39;wifi&#39;:
                        aux = np.random.normal(0, 0.2, size=(3, num_data))
                    else:
                        aux = np.random.normal(0, 0.2, size=(5, num_data))
                else:
                    aux = None

                data.timestamp = datetime.now().timestamp() * 1000
                data.value[&#39;timestamp&#39;] = datetime.now()
                data.value[&#39;data&#39;] = eeg, aux

                if &#39;eeg&#39; in topics:
                    if hasattr(cls, &#39;buffer_eeg&#39;):
                        cls.update_buffer(
                            *data.value[&#39;data&#39;], data.value[&#39;timestamp&#39;].timestamp())

                    kwargs = {&#39;data&#39;: data.value[&#39;data&#39;],
                              &#39;kafka_stream&#39;: data,
                              &#39;topic&#39;: &#39;eeg&#39;,
                              &#39;frame&#39;: frame,
                              &#39;latency&#39;: 0,
                              }
                    fn(*[cls] + [kwargs[v] for v in arguments])

                if &#39;marker&#39; in topics:
                    if np.random.random() &gt; 0.9:
                        data.value[&#39;timestamp&#39;] = datetime.now()
                        data.value[&#39;context&#39;][&#39;binary_created&#39;] = datetime.now()
                        # data.value[&#39;data&#39;] = chr(
                            # np.random.choice(range(ord(&#39;A&#39;), ord(&#39;Z&#39;) + 1)))
                        data.value[&#39;data&#39;] = random.choice(
                            [&#39;Right&#39;, &#39;Left&#39;, &#39;Up&#39;, &#39;Bottom&#39;])

                        kwargs = {&#39;data&#39;: data.value[&#39;data&#39;],
                                  &#39;kafka_stream&#39;: data,
                                  &#39;topic&#39;: &#39;marker&#39;,
                                  &#39;frame&#39;: frame,
                                  &#39;latency&#39;: 0,
                                  }
                        fn(*[cls] + [kwargs[v] for v in arguments])

                while time.time() &lt; (t0 + 1 / (prop.SAMPLE_RATE / prop.STREAMING_PACKAGE_SIZE)):
                    time.sleep(0.0001)

        return wrap
    return wrap_wrap</div>


# ----------------------------------------------------------------------
def marker_slicing(markers, t0, duration):
    &quot;&quot;&quot;&quot;&quot;&quot;
    if isinstance(markers, str):
        markers = [markers]

    def wrap_wrap(fn):

        arguments = fn.__code__.co_varnames[1:fn.__code__.co_argcount]

        def wrap(cls):
            cls._target_marker = []

            @loop_consumer(&#39;eeg&#39;, &#39;marker&#39;)
            def marker_slicing_(cls, topic, data, kafka_stream, latency):

                if topic == &#39;marker&#39;:
                    # if data[&#39;marker&#39;] in markers:
                        # cls._target_marker.append(
                            # [data[&#39;marker&#39;], kafka_stream.value[&#39;datetime&#39;]])

                    if any([bool(re.match(mkr, data[&#39;marker&#39;])) for mkr in markers]):
                        cls._target_marker.append(
                            [data[&#39;marker&#39;], kafka_stream.value[&#39;datetime&#39;]])

                if target := getattr(cls, &#39;_target_marker&#39;, False):

                    # marker, target = target
                    if cls.buffer_timestamp[-1] &gt; (datetime.fromtimestamp(target[0][1]) + timedelta(seconds=duration - t0)).timestamp():

                        _marker, _target = target.pop(0)

                        argmin = np.abs(cls.buffer_timestamp - _target).argmin()

                        start = int((prop.SAMPLE_RATE) * t0)
                        stop = int((prop.SAMPLE_RATE) * (duration + t0))

                        t = cls.buffer_timestamp[argmin + start:argmin + stop]
                        eeg = cls.buffer_eeg[:, argmin + start:argmin + stop]
                        aux = cls.buffer_aux[:, argmin + start:argmin + stop]

                        kwargs = {&#39;eeg&#39;: eeg,
                                  &#39;aux&#39;: aux,
                                  &#39;timestamp&#39;: t,
                                  &#39;marker_datetime&#39;: _target,
                                  &#39;marker&#39;: _marker,
                                  &#39;latency&#39;: latency,
                                  }

                        fn(*[cls] + [kwargs[v] for v in arguments])

            marker_slicing_(cls)
        return wrap
    return wrap_wrap
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/logo.svg" alt="Logo"/>
            </a></p><h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/00-installation.html">Installation and running</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/01-configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/02-interface.html">Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/70-data_analysis.html">Data analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/75-data_visualizations.html">Data visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/76-default_visualizations.html">Examples of data visualizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/80-stimuli_delivery.html">Stimuli delivery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/81-default_stimuli_delivery_paradigms.html">Examples of stimuli delivery paradigms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/90-event_marker_synchronization.html">Event marker synchronization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/91-eeg_records_exploring.html">EEG records exploring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/99-ilustrative_example.html">Illustrative example</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Yeison Cardona.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>